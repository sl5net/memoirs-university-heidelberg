<html><head>
<style type="text/css"> 
A 					{ font-size: 11pt; text-decoration: none; } 
A:Hover, A:Active 	{ font-size: 12pt; text-decoration: underline; color: black; }
</style>
<script language="JavaScript">
var backup_text, text_is_sql = true;
function show_text_in_form(t , s ){	
	set_backup();
	document.forms[0].elements['sql'].value = t; 
	text_is_sql = false;
	window.status = s;
	//alert(s);
}
function load_backup(){ 
	if(!text_is_sql && backup_text){
		document.forms[0].elements['sql'].value = backup_text; 
		text_is_sql = true;
	}
	//alert('load_backup'); 
}
function set_backup(){	
	if(text_is_sql) {
		with (document.forms[0].elements['sql'] ) {
			if( value ){ backup_text = value; text_is_sql = true; }
		}
	}
	//alert('set_backup'); 
}
function on_load(){	set_backup(); }
</script>
</head><body onload="on_load()">
<font size="-1">Aufgabe 4.4.5 Eine kleine Applikation</font> - 
odbc_connect ok! (<font size=-3>Resource id #2</font>)<br>SELECT * FROM <font size="-1"><a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20benachbart&table_name=benachbart.htm" accesskey="b">benachbart</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20berg&table_name=berg.htm" accesskey="b">berg</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20ebene&table_name=ebene.htm" accesskey="e">ebene</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20flug&table_name=flug.htm" accesskey="f">flug</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20flughafen&table_name=flughafen.htm" accesskey="f">flughafen</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20fluss&table_name=fluss.htm" accesskey="f">fluss</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20flussquelle&table_name=flussquelle.htm" accesskey="f">flussquelle</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20gehoert_lt&table_name=gehoert_lt.htm" accesskey="g">gehoert_lt</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20geht_ueber&table_name=geht_ueber.htm" accesskey="g">geht_ueber</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20geo_berg&table_name=geo_berg.htm" accesskey="g">geo_berg</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20geo_ebene&table_name=geo_ebene.htm" accesskey="g">geo_ebene</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20geo_gewaesser&table_name=geo_gewaesser.htm" accesskey="g">geo_gewaesser</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20geo_insel&table_name=geo_insel.htm" accesskey="g">geo_insel</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20geo_wueste&table_name=geo_wueste.htm" accesskey="g">geo_wueste</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20gewaesser&table_name=gewaesser.htm" accesskey="g">gewaesser</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20hat_sitz_in&table_name=hat_sitz_in.htm" accesskey="h">hat_sitz_in</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20insel&table_name=insel.htm" accesskey="i">insel</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20ist_mitglied&table_name=ist_mitglied.htm" accesskey="i">ist_mitglied</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20kontinent&table_name=kontinent.htm" accesskey="k">kontinent</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20land&table_name=land.htm" accesskey="l">land</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20landesteil&table_name=landesteil.htm" accesskey="l">landesteil</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20liegt_an&table_name=liegt_an.htm" accesskey="l">liegt_an</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20meer&table_name=meer.htm" accesskey="m">meer</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20muendet&table_name=muendet.htm" accesskey="m">muendet</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20organisation&table_name=organisation.htm" accesskey="o">organisation</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20see&table_name=see.htm" accesskey="s">see</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20stadt&table_name=stadt.htm" accesskey="s">stadt</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20test&table_name=test.htm" accesskey="t">test</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20umfasst&table_name=umfasst.htm" accesskey="u">umfasst</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20wueste&table_name=wueste.htm" accesskey="w">wueste</a> <hr><font size="+1"> <b>&#664</b> <em>Aufg.</em><b><u>2.3.3.1</u></b> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=1.htm"
 onmouseover="show_text_in_form('Geben Sie alle Stdte an, die ungefhr 100.000 Einwohner haben. \nSortieren Sie die Stdte  \nnach der Abweichung von dieser Einwohnerzahl  \n(Stdte mit kleinerer Abweichung stehen weiter vorne in der Liste). \n \nGeben Sie alle Stdte an, die um maximal 10.000 Einwohner von 100.000 Einwohnern abweichen.','SELECT name, einwohner, ABS( einwohner - 100000 ) AS abweichung FROM STADT WHERE einwohner + 10000 >= 100000 AND einwohner - 10000 <= 100000 ORDER BY ABS( einwohner - 100000 )');"
 >SEL...</a> 
<a href="javascript:show_text_in_form('SELECT name, einwohner, ABS( einwohner - 100000 ) AS abweichung FROM STADT WHERE einwohner + 10000 >= 100000 AND einwohner - 10000 <= 100000 ORDER BY ABS( einwohner - 100000 )','SELECT name, einwohner, ABS( einwohner - 100000 ) AS abweichung FROM STADT WHERE einwohner + 10000 >= 100000 AND einwohner - 10000 <= 100000 ORDER BY ABS( einwohner - 100000 )');alert('Geben Sie alle Stdte an, die ungefhr 100.000 Einwohner haben. \nSortieren Sie die Stdte  \nnach der Abweichung von dieser Einwohnerzahl  \n(Stdte mit kleinerer Abweichung stehen weiter vorne in der Liste). \n \nGeben Sie alle Stdte an, die um maximal 10.000 Einwohner von 100.000 Einwohnern abweichen.');"
 onmouseover="show_text_in_form('Geben Sie alle Stdte an, die ungefhr 100.000 Einwohner haben. \nSortieren Sie die Stdte  \nnach der Abweichung von dieser Einwohnerzahl  \n(Stdte mit kleinerer Abweichung stehen weiter vorne in der Liste). \n \nGeben Sie alle Stdte an, die um maximal 10.000 Einwohner von 100.000 Einwohnern abweichen.','SELECT name, einwohner, ABS( einwohner - 100000 ) AS abweichung FROM STADT WHERE einwohner + 10000 >= 100000 AND einwohner - 10000 <= 100000 ORDER BY ABS( einwohner - 100000 )');"
 
 onkeypress="'SELECT name, einwohner, ABS( einwohner - 100000 ) AS abweichung FROM STADT WHERE einwohner + 10000 >= 100000 AND einwohner - 10000 <= 100000 ORDER BY ABS( einwohner - 100000 )'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em><b><u>2.3.3.2</u> hnlichkeit mittels LOCATE|SOUNDEX|DIFFERENCE</b> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=2.htm"
 onmouseover="show_text_in_form('Geben Sie alle Lnder an, deren Hauptstadtname hnlichkeit mit dem Landesnamen hat. \nDie Lsung ganz am Ende mit DIFFERENCE gefllt mir am besten. \n','SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlnge , length( RTRIM(l.name) ) AS Landlnge FROM land l, stadt s ### LOCATE( s1, s2 ) -> Integer ### gibt die Position des ersten Auftauchens von String s2 in String s1 an. WHERE l.hauptstadt = s.s_id AND ( LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 OR LOCATE(RTRIM(l.name), RTRIM( s.name)) > 0 ) ; ### Zur Verdeutlichung einmal nur das enthaltensein von Stadtnamen im Landesnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlnge , length( RTRIM(l.name) ) AS Landlnge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 ; ### Und noch einmal umgekehrt, das enthaltensein von Landesnamen im Stadtnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlnge , length( RTRIM(l.name) ) AS Landlnge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE( RTRIM( l.name) , RTRIM(s.name) ) > 0 ; ### Alternative Lsung mit Funktion SOUNDEX() SELECT s.name AS Stadt, l.name AS Land FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND SOUNDEX(s.name) = SOUNDEX(l.name); ### Alternative Lsung mit Funktion DIFFERENCE( s1, s2 ) Klangbereinstimmung zw. 0 und 4 SELECT s.name AS Stadt, l.name AS Land, DIFFERENCE( s.name , l.name ) as Klangbereinstimmung FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND DIFFERENCE( s.name , l.name ) > 2 ORDER BY Klangbereinstimmung DESC ;');"
 >SEL...</a> 
<a href="javascript:show_text_in_form('SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlnge , length( RTRIM(l.name) ) AS Landlnge FROM land l, stadt s ### LOCATE( s1, s2 ) -> Integer ### gibt die Position des ersten Auftauchens von String s2 in String s1 an. WHERE l.hauptstadt = s.s_id AND ( LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 OR LOCATE(RTRIM(l.name), RTRIM( s.name)) > 0 ) ; ### Zur Verdeutlichung einmal nur das enthaltensein von Stadtnamen im Landesnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlnge , length( RTRIM(l.name) ) AS Landlnge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 ; ### Und noch einmal umgekehrt, das enthaltensein von Landesnamen im Stadtnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlnge , length( RTRIM(l.name) ) AS Landlnge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE( RTRIM( l.name) , RTRIM(s.name) ) > 0 ; ### Alternative Lsung mit Funktion SOUNDEX() SELECT s.name AS Stadt, l.name AS Land FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND SOUNDEX(s.name) = SOUNDEX(l.name); ### Alternative Lsung mit Funktion DIFFERENCE( s1, s2 ) Klangbereinstimmung zw. 0 und 4 SELECT s.name AS Stadt, l.name AS Land,%20difference%28%20s.name , l.name ) as Klangbereinstimmung FROM land l,%20stadt%20s%20where%20l.hauptstadt%20=%20s.s_id%20and%20difference%28%20s.name , l.name ) > 2 ORDER BY Klangbereinstimmung DESC ;','SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlnge , length( RTRIM(l.name) ) AS Landlnge FROM land l, stadt s ### LOCATE( s1, s2 ) -> Integer ### gibt die Position des ersten Auftauchens von String s2 in String s1 an. WHERE l.hauptstadt = s.s_id AND ( LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 OR LOCATE(RTRIM(l.name), RTRIM( s.name)) > 0 ) ; ### Zur Verdeutlichung einmal nur das enthaltensein von Stadtnamen im Landesnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlnge , length( RTRIM(l.name) ) AS Landlnge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 ; ### Und noch einmal umgekehrt, das enthaltensein von Landesnamen im Stadtnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlnge , length( RTRIM(l.name) ) AS Landlnge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE( RTRIM( l.name) , RTRIM(s.name) ) > 0 ; ### Alternative Lsung mit Funktion SOUNDEX() SELECT s.name AS Stadt, l.name AS Land FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND SOUNDEX(s.name) = SOUNDEX(l.name); ### Alternative Lsung mit Funktion DIFFERENCE( s1, s2 ) Klangbereinstimmung zw. 0 und 4 SELECT s.name AS Stadt, l.name AS Land,%20difference%28%20s.name , l.name ) as Klangbereinstimmung FROM land l,%20stadt%20s%20where%20l.hauptstadt%20=%20s.s_id%20and%20difference%28%20s.name , l.name ) > 2 ORDER BY Klangbereinstimmung DESC ;');alert('Geben Sie alle Lnder an, deren Hauptstadtname hnlichkeit mit dem Landesnamen hat. \nDie Lsung ganz am Ende mit DIFFERENCE gefllt mir am besten. \n');"
 onmouseover="show_text_in_form('Geben Sie alle Lnder an, deren Hauptstadtname hnlichkeit mit dem Landesnamen hat. \nDie Lsung ganz am Ende mit DIFFERENCE gefllt mir am besten. \n','SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlnge , length( RTRIM(l.name) ) AS Landlnge FROM land l, stadt s ### LOCATE( s1, s2 ) -> Integer ### gibt die Position des ersten Auftauchens von String s2 in String s1 an. WHERE l.hauptstadt = s.s_id AND ( LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 OR LOCATE(RTRIM(l.name), RTRIM( s.name)) > 0 ) ; ### Zur Verdeutlichung einmal nur das enthaltensein von Stadtnamen im Landesnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlnge , length( RTRIM(l.name) ) AS Landlnge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 ; ### Und noch einmal umgekehrt, das enthaltensein von Landesnamen im Stadtnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlnge , length( RTRIM(l.name) ) AS Landlnge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE( RTRIM( l.name) , RTRIM(s.name) ) > 0 ; ### Alternative Lsung mit Funktion SOUNDEX() SELECT s.name AS Stadt, l.name AS Land FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND SOUNDEX(s.name) = SOUNDEX(l.name); ### Alternative Lsung mit Funktion DIFFERENCE( s1, s2 ) Klangbereinstimmung zw. 0 und 4 SELECT s.name AS Stadt, l.name AS Land, DIFFERENCE( s.name , l.name ) as Klangbereinstimmung FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND DIFFERENCE( s.name , l.name ) > 2 ORDER BY Klangbereinstimmung DESC ;');"
 
 onkeypress="'SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlnge , length( RTRIM(l.name) ) AS Landlnge FROM land l, stadt s ### LOCATE( s1, s2 ) -> Integer ### gibt die Position des ersten Auftauchens von String s2 in String s1 an. WHERE l.hauptstadt = s.s_id AND ( LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 OR LOCATE(RTRIM(l.name), RTRIM( s.name)) > 0 ) ; ### Zur Verdeutlichung einmal nur das enthaltensein von Stadtnamen im Landesnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlnge , length( RTRIM(l.name) ) AS Landlnge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 ; ### Und noch einmal umgekehrt, das enthaltensein von Landesnamen im Stadtnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlnge , length( RTRIM(l.name) ) AS Landlnge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE( RTRIM( l.name) , RTRIM(s.name) ) > 0 ; ### Alternative Lsung mit Funktion SOUNDEX() SELECT s.name AS Stadt, l.name AS Land FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND SOUNDEX(s.name) = SOUNDEX(l.name); ### Alternative Lsung mit Funktion DIFFERENCE( s1, s2 ) Klangbereinstimmung zw. 0 und 4 SELECT s.name AS Stadt, l.name AS Land, DIFFERENCE( s.name , l.name ) as Klangbereinstimmung FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND DIFFERENCE( s.name , l.name ) > 2 ORDER BY Klangbereinstimmung DESC ;'">Text</a></font><font size="+1"> <b>&#664</b> INSERT .. MAX(S_ID) <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=3.htm"
 onmouseover="show_text_in_form('Insert in eine Tabelle.','INSERT INTO stadt ( s_id, name, einwohner ) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 12345 ); SELECT * FROM stadt WHERE S_ID > 629; DELETE FROM STADT WHERE S_ID > 629');"
 >INS...</a> 
<a href="javascript:show_text_in_form('INSERT INTO stadt ( s_id, name, einwohner ) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 12345 ); SELECT * FROM stadt WHERE S_ID > 629; DELETE FROM STADT WHERE S_ID > 629','INSERT INTO stadt ( s_id, name, einwohner ) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 12345 ); SELECT * FROM stadt WHERE S_ID > 629; DELETE FROM STADT WHERE S_ID > 629');alert('Insert in eine Tabelle.');"
 onmouseover="show_text_in_form('Insert in eine Tabelle.','INSERT INTO stadt ( s_id, name, einwohner ) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 12345 ); SELECT * FROM stadt WHERE S_ID > 629; DELETE FROM STADT WHERE S_ID > 629');"
 
 onkeypress="'INSERT INTO stadt ( s_id, name, einwohner ) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 12345 ); SELECT * FROM stadt WHERE S_ID > 629; DELETE FROM STADT WHERE S_ID > 629'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em><b><u>2.3.3.3 a), b), c), d), e), f)</u></b> &nbsp;VIEW <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=4.htm"
 onmouseover="show_text_in_form('Erzeugen Sie mit einer Sicht einen Auschnitt der Relation Stadt,  \nin der alle Stdte mit mehr als fnf Millionen Einwohnern eingetragen sind.  \nbernehmen Sie in die Sicht die Attribute S ID, Name und Einwohner.  \n \nWeitere Teilaufgaben zwischen dem SQL- Befehl formuliert. \nBeschreiben Sie fr die folgenden Operationen jeweils die Reaktionen des Datenbanksystems: \n','CREATE VIEW stadtview ( s_id, name, einwohner) AS SELECT s_id, name, einwohner FROM stadt WHERE einwohner > 10000000; # Die Sicht ist erzeugt, jetzt wollen doch mal sehen was so drin steckt. SELECT * FROM stadtview; # 2.3.3.3 a) Stadt in Sicht mit mehr als fnf Millionen Einwohnern einfgen und ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview), \'TestStadt\', 10000001 ); SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id # Interessant ist, das der eben eingefgte Datensatz zweimal angezeigt wird. # Man sieht (vielleicht berraschend) dass der Datensatz in Tabelle stadt eingefgt wurde. # obwohl der insert_ eindeutig in die view einfgt. ; # 2.3.3.3 b) DELETE FROM stadtview WHERE name = \'TestStadt\' # Wir werden gleich sehen, das sich dieses lschen # wieder auf die Tabelle ausgwirkte. Im View ist der Eintrag auch nicht mehr zu finden. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 c) # Fgen Sie eine Stadt mit weniger als fnf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht und die Relation Stadt ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 11 ) # Wir werden sehen, dieser neue Datensatz erstens wieder in Tabelle stadt # eingefgt wurde und zweitens in stadtview nicht mehr auftaucht, ganz gem溥 # der Bedinungen des VIEWS bezglich der Einwohnerzahl. Fein :) # Also alles so wie es sein sollte. Der VIEW bleibt stimmig. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 d) # Fgen Sie die Stadt erneut mit mehr als fnf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 10000002 ) # Interessant hier gibt es eine Fehlermeldung, weil dieser Index fr den letzten Einfug in stadt # verwendet wurde, also belegt ist. # Dies wird nicht erkannt bzw. bercksichtig, da letzer Einfug nicht im VIEW vermerkt ist. ; SELECT MAX(v.S_ID)+99 AS 创MAX(v.S_ID)+99创, MAX(v.S_ID) AS 创MAX(v.S_ID)创, MAX(s.S_ID)+99 AS 创MAX(s.S_ID)+99创, MAX(s.S_ID) AS 创MAX(s.S_ID)创 FROM stadtview AS v, stadt AS s ; INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 10000002 ) ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 e) # Lschen Sie die Stadt aus der Sicht. DELETE FROM stadtview WHERE einwohner = 10000002 ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 f) # Lschen Sie die Stadt aus der Relation Stadt. DELETE FROM stadt WHERE einwohner = 10000002 # Klar, wir wissen ja, das hat auswirkungen auf VIEWs und RELATION ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # Und wieder lschen, fr den nchsten Versuch :) DROP VIEW stadtview; DELETE FROM STADT WHERE S_ID > 629;');"
 >CRE...</a> 
<a href="javascript:show_text_in_form('CREATE VIEW stadtview ( s_id, name, einwohner) AS SELECT s_id, name, einwohner FROM stadt WHERE einwohner > 10000000; # Die Sicht ist erzeugt, jetzt wollen doch mal sehen was so drin steckt. SELECT * FROM stadtview; # 2.3.3.3 a) Stadt in Sicht mit mehr als fnf Millionen Einwohnern einfgen und ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview), \'TestStadt\', 10000001 ); SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id # Interessant ist, das der eben eingefgte Datensatz zweimal angezeigt wird. # Man sieht (vielleicht berraschend) dass der Datensatz in Tabelle stadt eingefgt wurde. # obwohl der insert_ eindeutig in die view einfgt. ; # 2.3.3.3 b) DELETE FROM stadtview WHERE name = \'TestStadt\' # Wir werden gleich sehen, das sich dieses lschen # wieder auf die Tabelle ausgwirkte. Im View ist der Eintrag auch nicht mehr zu finden. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 c) # Fgen Sie eine Stadt mit weniger als fnf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht und die Relation Stadt ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 11 ) # Wir werden sehen, dieser neue Datensatz erstens wieder in Tabelle stadt # eingefgt wurde und zweitens in stadtview nicht mehr auftaucht, ganz gem溥 # der Bedinungen des VIEWS bezglich der Einwohnerzahl. Fein :) # Also alles so wie es sein sollte. Der VIEW bleibt stimmig. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 d) # Fgen Sie die Stadt erneut mit mehr als fnf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 10000002 ) # Interessant hier gibt es eine Fehlermeldung, weil dieser Index fr den letzten Einfug in stadt # verwendet wurde, also belegt ist. # Dies wird nicht erkannt bzw. bercksichtig, da letzer Einfug nicht im VIEW vermerkt ist. ; SELECT MAX(v.S_ID)+99 AS 创MAX(v.S_ID)+99创, MAX(v.S_ID) AS 创MAX(v.S_ID)创, MAX(s.S_ID)+99 AS 创MAX(s.S_ID)+99创, MAX(s.S_ID) AS 创MAX(s.S_ID)创 FROM stadtview AS v, stadt AS s ; INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 10000002 ) ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 e) # Lschen Sie die Stadt aus der Sicht. DELETE FROM stadtview WHERE einwohner = 10000002 ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 f) # Lschen Sie die Stadt aus der Relation Stadt. DELETE FROM stadt WHERE einwohner = 10000002 # Klar, wir wissen ja, das hat auswirkungen auf VIEWs und RELATION ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # Und wieder lschen, fr den nchsten Versuch :) DROP VIEW stadtview; DELETE FROM STADT WHERE S_ID > 629;','CREATE VIEW stadtview ( s_id, name, einwohner) AS SELECT s_id, name, einwohner FROM stadt WHERE einwohner > 10000000; # Die Sicht ist erzeugt, jetzt wollen doch mal sehen was so drin steckt. SELECT * FROM stadtview; # 2.3.3.3 a) Stadt in Sicht mit mehr als fnf Millionen Einwohnern einfgen und ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview), \'TestStadt\', 10000001 ); SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id # Interessant ist, das der eben eingefgte Datensatz zweimal angezeigt wird. # Man sieht (vielleicht berraschend) dass der Datensatz in Tabelle stadt eingefgt wurde. # obwohl der insert_ eindeutig in die view einfgt. ; # 2.3.3.3 b) DELETE FROM stadtview WHERE name = \'TestStadt\' # Wir werden gleich sehen, das sich dieses lschen # wieder auf die Tabelle ausgwirkte. Im View ist der Eintrag auch nicht mehr zu finden. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 c) # Fgen Sie eine Stadt mit weniger als fnf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht und die Relation Stadt ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 11 ) # Wir werden sehen, dieser neue Datensatz erstens wieder in Tabelle stadt # eingefgt wurde und zweitens in stadtview nicht mehr auftaucht, ganz gem溥 # der Bedinungen des VIEWS bezglich der Einwohnerzahl. Fein :) # Also alles so wie es sein sollte. Der VIEW bleibt stimmig. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 d) # Fgen Sie die Stadt erneut mit mehr als fnf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 10000002 ) # Interessant hier gibt es eine Fehlermeldung, weil dieser Index fr den letzten Einfug in stadt # verwendet wurde, also belegt ist. # Dies wird nicht erkannt bzw. bercksichtig, da letzer Einfug nicht im VIEW vermerkt ist. ; SELECT MAX(v.S_ID)+99 AS 创MAX(v.S_ID)+99创, MAX(v.S_ID) AS 创MAX(v.S_ID)创, MAX(s.S_ID)+99 AS 创MAX(s.S_ID)+99创, MAX(s.S_ID) AS 创MAX(s.S_ID)创 FROM stadtview AS v, stadt AS s ; INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 10000002 ) ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 e) # Lschen Sie die Stadt aus der Sicht. DELETE FROM stadtview WHERE einwohner = 10000002 ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 f) # Lschen Sie die Stadt aus der Relation Stadt. DELETE FROM stadt WHERE einwohner = 10000002 # Klar, wir wissen ja, das hat auswirkungen auf VIEWs und RELATION ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # Und wieder lschen, fr den nchsten Versuch :) DROP VIEW stadtview; DELETE FROM STADT WHERE S_ID > 629;');alert('Erzeugen Sie mit einer Sicht einen Auschnitt der Relation Stadt,  \nin der alle Stdte mit mehr als fnf Millionen Einwohnern eingetragen sind.  \nbernehmen Sie in die Sicht die Attribute S ID, Name und Einwohner.  \n \nWeitere Teilaufgaben zwischen dem SQL- Befehl formuliert. \nBeschreiben Sie fr die folgenden Operationen jeweils die Reaktionen des Datenbanksystems: \n');"
 onmouseover="show_text_in_form('Erzeugen Sie mit einer Sicht einen Auschnitt der Relation Stadt,  \nin der alle Stdte mit mehr als fnf Millionen Einwohnern eingetragen sind.  \nbernehmen Sie in die Sicht die Attribute S ID, Name und Einwohner.  \n \nWeitere Teilaufgaben zwischen dem SQL- Befehl formuliert. \nBeschreiben Sie fr die folgenden Operationen jeweils die Reaktionen des Datenbanksystems: \n','CREATE VIEW stadtview ( s_id, name, einwohner) AS SELECT s_id, name, einwohner FROM stadt WHERE einwohner > 10000000; # Die Sicht ist erzeugt, jetzt wollen doch mal sehen was so drin steckt. SELECT * FROM stadtview; # 2.3.3.3 a) Stadt in Sicht mit mehr als fnf Millionen Einwohnern einfgen und ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview), \'TestStadt\', 10000001 ); SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id # Interessant ist, das der eben eingefgte Datensatz zweimal angezeigt wird. # Man sieht (vielleicht berraschend) dass der Datensatz in Tabelle stadt eingefgt wurde. # obwohl der insert_ eindeutig in die view einfgt. ; # 2.3.3.3 b) DELETE FROM stadtview WHERE name = \'TestStadt\' # Wir werden gleich sehen, das sich dieses lschen # wieder auf die Tabelle ausgwirkte. Im View ist der Eintrag auch nicht mehr zu finden. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 c) # Fgen Sie eine Stadt mit weniger als fnf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht und die Relation Stadt ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 11 ) # Wir werden sehen, dieser neue Datensatz erstens wieder in Tabelle stadt # eingefgt wurde und zweitens in stadtview nicht mehr auftaucht, ganz gem溥 # der Bedinungen des VIEWS bezglich der Einwohnerzahl. Fein :) # Also alles so wie es sein sollte. Der VIEW bleibt stimmig. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 d) # Fgen Sie die Stadt erneut mit mehr als fnf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 10000002 ) # Interessant hier gibt es eine Fehlermeldung, weil dieser Index fr den letzten Einfug in stadt # verwendet wurde, also belegt ist. # Dies wird nicht erkannt bzw. bercksichtig, da letzer Einfug nicht im VIEW vermerkt ist. ; SELECT MAX(v.S_ID)+99 AS 创MAX(v.S_ID)+99创, MAX(v.S_ID) AS 创MAX(v.S_ID)创, MAX(s.S_ID)+99 AS 创MAX(s.S_ID)+99创, MAX(s.S_ID) AS 创MAX(s.S_ID)创 FROM stadtview AS v, stadt AS s ; INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 10000002 ) ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 e) # Lschen Sie die Stadt aus der Sicht. DELETE FROM stadtview WHERE einwohner = 10000002 ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 f) # Lschen Sie die Stadt aus der Relation Stadt. DELETE FROM stadt WHERE einwohner = 10000002 # Klar, wir wissen ja, das hat auswirkungen auf VIEWs und RELATION ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # Und wieder lschen, fr den nchsten Versuch :) DROP VIEW stadtview; DELETE FROM STADT WHERE S_ID > 629;');"
 
 onkeypress="'CREATE VIEW stadtview ( s_id, name, einwohner) AS SELECT s_id, name, einwohner FROM stadt WHERE einwohner > 10000000; # Die Sicht ist erzeugt, jetzt wollen doch mal sehen was so drin steckt. SELECT * FROM stadtview; # 2.3.3.3 a) Stadt in Sicht mit mehr als fnf Millionen Einwohnern einfgen und ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview), \'TestStadt\', 10000001 ); SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id # Interessant ist, das der eben eingefgte Datensatz zweimal angezeigt wird. # Man sieht (vielleicht berraschend) dass der Datensatz in Tabelle stadt eingefgt wurde. # obwohl der insert_ eindeutig in die view einfgt. ; # 2.3.3.3 b) DELETE FROM stadtview WHERE name = \'TestStadt\' # Wir werden gleich sehen, das sich dieses lschen # wieder auf die Tabelle ausgwirkte. Im View ist der Eintrag auch nicht mehr zu finden. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 c) # Fgen Sie eine Stadt mit weniger als fnf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht und die Relation Stadt ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 11 ) # Wir werden sehen, dieser neue Datensatz erstens wieder in Tabelle stadt # eingefgt wurde und zweitens in stadtview nicht mehr auftaucht, ganz gem溥 # der Bedinungen des VIEWS bezglich der Einwohnerzahl. Fein :) # Also alles so wie es sein sollte. Der VIEW bleibt stimmig. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 d) # Fgen Sie die Stadt erneut mit mehr als fnf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 10000002 ) # Interessant hier gibt es eine Fehlermeldung, weil dieser Index fr den letzten Einfug in stadt # verwendet wurde, also belegt ist. # Dies wird nicht erkannt bzw. bercksichtig, da letzer Einfug nicht im VIEW vermerkt ist. ; SELECT MAX(v.S_ID)+99 AS 创MAX(v.S_ID)+99创, MAX(v.S_ID) AS 创MAX(v.S_ID)创, MAX(s.S_ID)+99 AS 创MAX(s.S_ID)+99创, MAX(s.S_ID) AS 创MAX(s.S_ID)创 FROM stadtview AS v, stadt AS s ; INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 10000002 ) ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 e) # Lschen Sie die Stadt aus der Sicht. DELETE FROM stadtview WHERE einwohner = 10000002 ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 f) # Lschen Sie die Stadt aus der Relation Stadt. DELETE FROM stadt WHERE einwohner = 10000002 # Klar, wir wissen ja, das hat auswirkungen auf VIEWs und RELATION ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # Und wieder lschen, fr den nchsten Versuch :) DROP VIEW stadtview; DELETE FROM STADT WHERE S_ID > 629;'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em><b><u>2.3.4.1</u></b> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=5.htm"
 onmouseover="show_text_in_form('Bestimmung smtliche Nachbar-IDs von Bundesrepublik_Deutschland. \nTip: Eine Sicht anzulegen, um nur eine Anfrage zu stellen, ist etwas umstndlich.  \nDafr gibt es die WITH-Anweisung.','select%20l.name, b.L_ID1, b.L_ID2 FROM LAND l , BENACHBART b WHERE l.NAME LIKE \'%Deutschland%\' AND ( l.L_ID = b.L_ID2 OR l.L_ID = b.L_ID1 )');"
 >SEL...</a> 
<a href="javascript:show_text_in_form('select%20l.name, b.L_ID1, b.L_ID2 FROM LAND l , BENACHBART b WHERE l.NAME LIKE \'%Deutschland%\' AND ( l.L_ID = b.L_ID2 OR l.L_ID = b.L_ID1 )','select%20l.name, b.L_ID1, b.L_ID2 FROM LAND l , BENACHBART b WHERE l.NAME LIKE \'%Deutschland%\' AND ( l.L_ID = b.L_ID2 OR l.L_ID = b.L_ID1 )');alert('Bestimmung smtliche Nachbar-IDs von Bundesrepublik_Deutschland. \nTip: Eine Sicht anzulegen, um nur eine Anfrage zu stellen, ist etwas umstndlich.  \nDafr gibt es die WITH-Anweisung.');"
 onmouseover="show_text_in_form('Bestimmung smtliche Nachbar-IDs von Bundesrepublik_Deutschland. \nTip: Eine Sicht anzulegen, um nur eine Anfrage zu stellen, ist etwas umstndlich.  \nDafr gibt es die WITH-Anweisung.','select%20l.name, b.L_ID1, b.L_ID2 FROM LAND l , BENACHBART b WHERE l.NAME LIKE \'%Deutschland%\' AND ( l.L_ID = b.L_ID2 OR l.L_ID = b.L_ID1 )');"
 
 onkeypress="'SELECT l.NAME, b.L_ID1, b.L_ID2 FROM LAND l , BENACHBART b WHERE l.NAME LIKE \'%Deutschland%\' AND ( l.L_ID = b.L_ID2 OR l.L_ID = b.L_ID1 )'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em>2.3.4.1 a) Bevlkerungsdichte <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=6.htm"
 onmouseover="show_text_in_form('Bestimmen Sie die Bevlkerungsdichte der Region, die die Lnder Algerien, \nLibyen und smtliche Nachbarn dieser Lnder umfat. \nTip: Eine Sicht anzulegen, um nur eine Anfrage zu stellen, ist etwas umstndlich. \n','SELECT * FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Wir brauchen also die Lnder Algerien, Libyen # Bevlkerungsdichte msste Einwohner pro Flche sein, also: SELECT name, einwohner/ flaeche AS 创Bevlkerungsdichte创 FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # zusammen SELECT avg(einwohner/ flaeche) AS 创Bevlkerungsdichte创 FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Ok soweit, jetzt sollten noch alle Nachbarn einbezogen werden. # Da hilft die Tabelle benachbart( l_id1 , l_id2 ) # Suchen wir erst mal alle Lnder ids der Nachbarn. SELECT l_id1, l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) OR l_id2 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) # Man muss hier aufpassen das man statt IN nicht versehentlich = schreibt. # Es gbe hier zwar keinen Fehler aber auch keine Ergebnisse. ; SELECT l_id1 AS 创l_id1 Nachbarn创, l_id2 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # So haben wir erst mal alle ids der Nachbarn in der Spalte l_id1 von 6 bzw. 84 # Aber es knnte vielleicht ja Nachbarn in der anderen Spalte auch gebeen. # Schaun wir mal. ; SELECT l_id1 , l_id2 AS 创l_id2 Nachbarn创 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # alle ids der Nachbarn stehen in der Spalte l_id2 von 6 bzw. 84 ; SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Jetzt haben wir tatschlich alle Nachbarlnder, aber es sieh etas unschn aus, finde ich. # Mit dem letzten beiden or kriegen wir unsere beiden Lnder auch noch hinnein. # Es sollte auch eleganter gehen. # Schauen wir mal was redundant ist und ersetzten dies mit einer temporren Sicht. ; # Folgender Ansatz, htte gehen sollen, geht aber nicht :( Warum eigentlich? WITH my_region (l_id) AS ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( my_region ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( my_region ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Dise Vereinfachung fhrt leider zu Fehler ... ich weiss auch nicht warum. ; WITH my_region (l_id) AS ( SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id2 AND b.l_id1 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') UNION SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id1 AND b.l_id2 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') ) SELECT l.name AS name, l.einwohner AS einwohner, l.flaeche AS flaeche FROM land l, my_region WHERE l.l_id = my_region.l_id # Das hier klappt.');"
 >SEL...</a> 
<a href="javascript:show_text_in_form('SELECT * FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Wir brauchen also die Lnder Algerien, Libyen # Bevlkerungsdichte msste Einwohner pro Flche sein, also: SELECT name, einwohner/ flaeche AS 创Bevlkerungsdichte创 FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # zusammen SELECT avg(einwohner/ flaeche) AS 创Bevlkerungsdichte创 FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Ok soweit, jetzt sollten noch alle Nachbarn einbezogen werden. # Da hilft die Tabelle benachbart( l_id1 , l_id2 ) # Suchen wir erst mal alle Lnder ids der Nachbarn. SELECT l_id1, l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) OR l_id2 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) # Man muss hier aufpassen das man statt IN nicht versehentlich = schreibt. # Es gbe hier zwar keinen Fehler aber auch keine Ergebnisse. ; SELECT l_id1 AS 创l_id1 Nachbarn创, l_id2 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # So haben wir erst mal alle ids der Nachbarn in der Spalte l_id1 von 6 bzw. 84 # Aber es knnte vielleicht ja Nachbarn in der anderen Spalte auch gebeen. # Schaun wir mal. ; SELECT l_id1 , l_id2 AS 创l_id2 Nachbarn创 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # alle ids der Nachbarn stehen in der Spalte l_id2 von 6 bzw. 84 ; SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Jetzt haben wir tatschlich alle Nachbarlnder, aber es sieh etas unschn aus, finde ich. # Mit dem letzten beiden or kriegen wir unsere beiden Lnder auch noch hinnein. # Es sollte auch eleganter gehen. # Schauen wir mal was redundant ist und ersetzten dies mit einer temporren Sicht. ; # Folgender Ansatz, htte gehen sollen, geht aber nicht :( Warum eigentlich? WITH my_region (l_id) AS ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( my_region ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( my_region ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Dise Vereinfachung fhrt leider zu Fehler ... ich weiss auch nicht warum. ; WITH my_region (l_id) AS ( SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id2 AND b.l_id1 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') UNION SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id1 AND b.l_id2 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') ) SELECT l.name AS name, l.einwohner AS einwohner, l.flaeche AS flaeche FROM land l, my_region WHERE l.l_id = my_region.l_id # Das hier klappt.','SELECT * FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Wir brauchen also die Lnder Algerien, Libyen # Bevlkerungsdichte msste Einwohner pro Flche sein, also: SELECT name, einwohner/ flaeche AS 创Bevlkerungsdichte创 FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # zusammen SELECT avg(einwohner/ flaeche) AS 创Bevlkerungsdichte创 FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Ok soweit, jetzt sollten noch alle Nachbarn einbezogen werden. # Da hilft die Tabelle benachbart( l_id1 , l_id2 ) # Suchen wir erst mal alle Lnder ids der Nachbarn. SELECT l_id1, l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) OR l_id2 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) # Man muss hier aufpassen das man statt IN nicht versehentlich = schreibt. # Es gbe hier zwar keinen Fehler aber auch keine Ergebnisse. ; SELECT l_id1 AS 创l_id1 Nachbarn创, l_id2 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # So haben wir erst mal alle ids der Nachbarn in der Spalte l_id1 von 6 bzw. 84 # Aber es knnte vielleicht ja Nachbarn in der anderen Spalte auch gebeen. # Schaun wir mal. ; SELECT l_id1 , l_id2 AS 创l_id2 Nachbarn创 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # alle ids der Nachbarn stehen in der Spalte l_id2 von 6 bzw. 84 ; SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Jetzt haben wir tatschlich alle Nachbarlnder, aber es sieh etas unschn aus, finde ich. # Mit dem letzten beiden or kriegen wir unsere beiden Lnder auch noch hinnein. # Es sollte auch eleganter gehen. # Schauen wir mal was redundant ist und ersetzten dies mit einer temporren Sicht. ; # Folgender Ansatz, htte gehen sollen, geht aber nicht :( Warum eigentlich? WITH my_region (l_id) AS ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( my_region ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( my_region ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Dise Vereinfachung fhrt leider zu Fehler ... ich weiss auch nicht warum. ; WITH my_region (l_id) AS ( SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id2 AND b.l_id1 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') UNION SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id1 AND b.l_id2 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') ) SELECT l.name AS name, l.einwohner AS einwohner, l.flaeche AS flaeche FROM land l, my_region WHERE l.l_id = my_region.l_id # Das hier klappt.');alert('Bestimmen Sie die Bevlkerungsdichte der Region, die die Lnder Algerien, \nLibyen und smtliche Nachbarn dieser Lnder umfat. \nTip: Eine Sicht anzulegen, um nur eine Anfrage zu stellen, ist etwas umstndlich. \n');"
 onmouseover="show_text_in_form('Bestimmen Sie die Bevlkerungsdichte der Region, die die Lnder Algerien, \nLibyen und smtliche Nachbarn dieser Lnder umfat. \nTip: Eine Sicht anzulegen, um nur eine Anfrage zu stellen, ist etwas umstndlich. \n','SELECT * FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Wir brauchen also die Lnder Algerien, Libyen # Bevlkerungsdichte msste Einwohner pro Flche sein, also: SELECT name, einwohner/ flaeche AS 创Bevlkerungsdichte创 FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # zusammen SELECT avg(einwohner/ flaeche) AS 创Bevlkerungsdichte创 FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Ok soweit, jetzt sollten noch alle Nachbarn einbezogen werden. # Da hilft die Tabelle benachbart( l_id1 , l_id2 ) # Suchen wir erst mal alle Lnder ids der Nachbarn. SELECT l_id1, l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) OR l_id2 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) # Man muss hier aufpassen das man statt IN nicht versehentlich = schreibt. # Es gbe hier zwar keinen Fehler aber auch keine Ergebnisse. ; SELECT l_id1 AS 创l_id1 Nachbarn创, l_id2 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # So haben wir erst mal alle ids der Nachbarn in der Spalte l_id1 von 6 bzw. 84 # Aber es knnte vielleicht ja Nachbarn in der anderen Spalte auch gebeen. # Schaun wir mal. ; SELECT l_id1 , l_id2 AS 创l_id2 Nachbarn创 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # alle ids der Nachbarn stehen in der Spalte l_id2 von 6 bzw. 84 ; SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Jetzt haben wir tatschlich alle Nachbarlnder, aber es sieh etas unschn aus, finde ich. # Mit dem letzten beiden or kriegen wir unsere beiden Lnder auch noch hinnein. # Es sollte auch eleganter gehen. # Schauen wir mal was redundant ist und ersetzten dies mit einer temporren Sicht. ; # Folgender Ansatz, htte gehen sollen, geht aber nicht :( Warum eigentlich? WITH my_region (l_id) AS ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( my_region ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( my_region ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Dise Vereinfachung fhrt leider zu Fehler ... ich weiss auch nicht warum. ; WITH my_region (l_id) AS ( SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id2 AND b.l_id1 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') UNION SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id1 AND b.l_id2 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') ) SELECT l.name AS name, l.einwohner AS einwohner, l.flaeche AS flaeche FROM land l, my_region WHERE l.l_id = my_region.l_id # Das hier klappt.');"
 
 onkeypress="'SELECT * FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Wir brauchen also die Lnder Algerien, Libyen # Bevlkerungsdichte msste Einwohner pro Flche sein, also: SELECT name, einwohner/ flaeche AS 创Bevlkerungsdichte创 FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # zusammen SELECT avg(einwohner/ flaeche) AS 创Bevlkerungsdichte创 FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Ok soweit, jetzt sollten noch alle Nachbarn einbezogen werden. # Da hilft die Tabelle benachbart( l_id1 , l_id2 ) # Suchen wir erst mal alle Lnder ids der Nachbarn. SELECT l_id1, l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) OR l_id2 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) # Man muss hier aufpassen das man statt IN nicht versehentlich = schreibt. # Es gbe hier zwar keinen Fehler aber auch keine Ergebnisse. ; SELECT l_id1 AS 创l_id1 Nachbarn创, l_id2 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # So haben wir erst mal alle ids der Nachbarn in der Spalte l_id1 von 6 bzw. 84 # Aber es knnte vielleicht ja Nachbarn in der anderen Spalte auch gebeen. # Schaun wir mal. ; SELECT l_id1 , l_id2 AS 创l_id2 Nachbarn创 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # alle ids der Nachbarn stehen in der Spalte l_id2 von 6 bzw. 84 ; SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Jetzt haben wir tatschlich alle Nachbarlnder, aber es sieh etas unschn aus, finde ich. # Mit dem letzten beiden or kriegen wir unsere beiden Lnder auch noch hinnein. # Es sollte auch eleganter gehen. # Schauen wir mal was redundant ist und ersetzten dies mit einer temporren Sicht. ; # Folgender Ansatz, htte gehen sollen, geht aber nicht :( Warum eigentlich? WITH my_region (l_id) AS ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( my_region ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( my_region ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Dise Vereinfachung fhrt leider zu Fehler ... ich weiss auch nicht warum. ; WITH my_region (l_id) AS ( SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id2 AND b.l_id1 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') UNION SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id1 AND b.l_id2 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') ) SELECT l.name AS name, l.einwohner AS einwohner, l.flaeche AS flaeche FROM land l, my_region WHERE l.l_id = my_region.l_id # Das hier klappt.'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em>2.3.4.1 b) Bevlkerungsdichte ohne Wsten <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=7.htm"
 onmouseover="show_text_in_form('2.3.4.1 b) Vergleichen Sie das Ergebnis mit der Bevlkerungsdichte die man erhlt, wenn \nman die Wsten als unbewohnbar bercksichtigt. \n','# Wsten wo sind die? SELECT w.w_id AS 创w.w_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创 FROM wueste AS w # Aber welche wsten muss ich bercksichtigen ? ; # Hat das was mit Tabelle geo_wueste zu tun ? SELECT g.lt_id AS 创g.lt_id创, g.w_id AS 创g.w_id创 FROM geo_wueste AS g ; # Und wohl der Tabelle landesteil SELECT l.lt_id AS 创lt.lt_id创, lt.name AS 创lt.name创, lt.l_id AS 创lt.l_id创, lt.einwohner AS 创lt.einwohner创, lt.lage AS 创lt.lage创, lt.hauptstadt AS 创lt.hauptstadt创 FROM landesteil AS lt # Hier sehen wir einen zusammenhang zwischen lt.lt_id und lt.l_id ; SELECT l.l_id AS 创l.l_id创, l.name AS 创l.name创, l.einwohner AS 创l.einwohner创, l.zuwachs AS 创l.zuwachs创, l.flaeche AS 创l.flaeche创, l.bsp AS 创l.bsp创, l.staatsform AS 创l.staatsform创, l.regierungschef AS 创l.regierungschef创, l.hauptstadt AS 创l.hauptstadt创 FROM land AS l # Hier haben wir dann wieder unsere l.l_id ; # Ich will erst mal ausgeben knnen wo eine Wste liegt, in welchem Land bzw. in welchen Lndern. SELECT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id ; Ich verstehe nicht warum es oben mehrere gleiche Ergebnisszeilen gibt, natrlich lassen sich die leicht entfernen: SELECT DISTINCT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id # Auerdem will ich diesen Zusammenhang fr alle 30 Wsten angezeigt haben, jetzt sind es aber pltzlich nur noch 2 ; SELECT DISTINCT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt,%20land%20as%20l%20where%20w.w_id%20=%20g.lt_id%20and%20g.lt_id%20=%20lt.lt_id%20and%20l0caf2b84, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name%29%20order%20by%20w.w_id, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name # Ich glaube wir mssen da mit UNION arbeiten ... nee ... oder wie? ; SELECT DISTINCT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id');"
 ># W...</a> 
<a href="javascript:show_text_in_form('# Wsten wo sind die? SELECT w.w_id AS 创w.w_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创 FROM wueste AS w # Aber welche wsten muss ich bercksichtigen ? ; # Hat das was mit Tabelle geo_wueste zu tun ? SELECT g.lt_id AS 创g.lt_id创, g.w_id AS 创g.w_id创 FROM geo_wueste AS g ; # Und wohl der Tabelle landesteil SELECT l.lt_id AS 创lt.lt_id创, lt.name AS 创lt.name创, lt.l_id AS 创lt.l_id创, lt.einwohner AS 创lt.einwohner创, lt.lage AS 创lt.lage创, lt.hauptstadt AS 创lt.hauptstadt创 FROM landesteil AS lt # Hier sehen wir einen zusammenhang zwischen lt.lt_id und lt.l_id ; SELECT l.l_id AS 创l.l_id创, l.name AS 创l.name创, l.einwohner AS 创l.einwohner创, l.zuwachs AS 创l.zuwachs创, l.flaeche AS 创l.flaeche创, l.bsp AS 创l.bsp创, l.staatsform AS 创l.staatsform创, l.regierungschef AS 创l.regierungschef创, l.hauptstadt AS 创l.hauptstadt创 FROM land AS l # Hier haben wir dann wieder unsere l.l_id ; # Ich will erst mal ausgeben knnen wo eine Wste liegt, in welchem Land bzw. in welchen Lndern. SELECT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id ; Ich verstehe nicht warum es oben mehrere gleiche Ergebnisszeilen gibt, natrlich lassen sich die leicht entfernen: SELECT DISTINCT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id # Auerdem will ich diesen Zusammenhang fr alle 30 Wsten angezeigt haben, jetzt sind es aber pltzlich nur noch 2 ; SELECT DISTINCT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt,%20land%20as%20l%20where%20w.w_id%20=%20g.lt_id%20and%20g.lt_id%20=%20lt.lt_id%20and%20l0caf2b84, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name%29%20order%20by%20w.w_id, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name # Ich glaube wir mssen da mit UNION arbeiten ... nee ... oder wie? ; SELECT DISTINCT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id','# Wsten wo sind die? SELECT w.w_id AS 创w.w_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创 FROM wueste AS w # Aber welche wsten muss ich bercksichtigen ? ; # Hat das was mit Tabelle geo_wueste zu tun ? SELECT g.lt_id AS 创g.lt_id创, g.w_id AS 创g.w_id创 FROM geo_wueste AS g ; # Und wohl der Tabelle landesteil SELECT l.lt_id AS 创lt.lt_id创, lt.name AS 创lt.name创, lt.l_id AS 创lt.l_id创, lt.einwohner AS 创lt.einwohner创, lt.lage AS 创lt.lage创, lt.hauptstadt AS 创lt.hauptstadt创 FROM landesteil AS lt # Hier sehen wir einen zusammenhang zwischen lt.lt_id und lt.l_id ; SELECT l.l_id AS 创l.l_id创, l.name AS 创l.name创, l.einwohner AS 创l.einwohner创, l.zuwachs AS 创l.zuwachs创, l.flaeche AS 创l.flaeche创, l.bsp AS 创l.bsp创, l.staatsform AS 创l.staatsform创, l.regierungschef AS 创l.regierungschef创, l.hauptstadt AS 创l.hauptstadt创 FROM land AS l # Hier haben wir dann wieder unsere l.l_id ; # Ich will erst mal ausgeben knnen wo eine Wste liegt, in welchem Land bzw. in welchen Lndern. SELECT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id ; Ich verstehe nicht warum es oben mehrere gleiche Ergebnisszeilen gibt, natrlich lassen sich die leicht entfernen: SELECT DISTINCT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id # Auerdem will ich diesen Zusammenhang fr alle 30 Wsten angezeigt haben, jetzt sind es aber pltzlich nur noch 2 ; SELECT DISTINCT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt,%20land%20as%20l%20where%20w.w_id%20=%20g.lt_id%20and%20g.lt_id%20=%20lt.lt_id%20and%20l0caf2b84, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name%29%20order%20by%20w.w_id, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name # Ich glaube wir mssen da mit UNION arbeiten ... nee ... oder wie? ; SELECT DISTINCT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id');alert('2.3.4.1 b) Vergleichen Sie das Ergebnis mit der Bevlkerungsdichte die man erhlt, wenn \nman die Wsten als unbewohnbar bercksichtigt. \n');"
 onmouseover="show_text_in_form('2.3.4.1 b) Vergleichen Sie das Ergebnis mit der Bevlkerungsdichte die man erhlt, wenn \nman die Wsten als unbewohnbar bercksichtigt. \n','# Wsten wo sind die? SELECT w.w_id AS 创w.w_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创 FROM wueste AS w # Aber welche wsten muss ich bercksichtigen ? ; # Hat das was mit Tabelle geo_wueste zu tun ? SELECT g.lt_id AS 创g.lt_id创, g.w_id AS 创g.w_id创 FROM geo_wueste AS g ; # Und wohl der Tabelle landesteil SELECT l.lt_id AS 创lt.lt_id创, lt.name AS 创lt.name创, lt.l_id AS 创lt.l_id创, lt.einwohner AS 创lt.einwohner创, lt.lage AS 创lt.lage创, lt.hauptstadt AS 创lt.hauptstadt创 FROM landesteil AS lt # Hier sehen wir einen zusammenhang zwischen lt.lt_id und lt.l_id ; SELECT l.l_id AS 创l.l_id创, l.name AS 创l.name创, l.einwohner AS 创l.einwohner创, l.zuwachs AS 创l.zuwachs创, l.flaeche AS 创l.flaeche创, l.bsp AS 创l.bsp创, l.staatsform AS 创l.staatsform创, l.regierungschef AS 创l.regierungschef创, l.hauptstadt AS 创l.hauptstadt创 FROM land AS l # Hier haben wir dann wieder unsere l.l_id ; # Ich will erst mal ausgeben knnen wo eine Wste liegt, in welchem Land bzw. in welchen Lndern. SELECT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id ; Ich verstehe nicht warum es oben mehrere gleiche Ergebnisszeilen gibt, natrlich lassen sich die leicht entfernen: SELECT DISTINCT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id # Auerdem will ich diesen Zusammenhang fr alle 30 Wsten angezeigt haben, jetzt sind es aber pltzlich nur noch 2 ; SELECT DISTINCT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt,%20land%20as%20l%20where%20w.w_id%20=%20g.lt_id%20and%20g.lt_id%20=%20lt.lt_id%20and%20l0caf2b84, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name%29%20order%20by%20w.w_id, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name # Ich glaube wir mssen da mit UNION arbeiten ... nee ... oder wie? ; SELECT DISTINCT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id');"
 
 onkeypress="'# Wsten wo sind die? SELECT w.w_id AS 创w.w_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创 FROM wueste AS w # Aber welche wsten muss ich bercksichtigen ? ; # Hat das was mit Tabelle geo_wueste zu tun ? SELECT g.lt_id AS 创g.lt_id创, g.w_id AS 创g.w_id创 FROM geo_wueste AS g ; # Und wohl der Tabelle landesteil SELECT l.lt_id AS 创lt.lt_id创, lt.name AS 创lt.name创, lt.l_id AS 创lt.l_id创, lt.einwohner AS 创lt.einwohner创, lt.lage AS 创lt.lage创, lt.hauptstadt AS 创lt.hauptstadt创 FROM landesteil AS lt # Hier sehen wir einen zusammenhang zwischen lt.lt_id und lt.l_id ; SELECT l.l_id AS 创l.l_id创, l.name AS 创l.name创, l.einwohner AS 创l.einwohner创, l.zuwachs AS 创l.zuwachs创, l.flaeche AS 创l.flaeche创, l.bsp AS 创l.bsp创, l.staatsform AS 创l.staatsform创, l.regierungschef AS 创l.regierungschef创, l.hauptstadt AS 创l.hauptstadt创 FROM land AS l # Hier haben wir dann wieder unsere l.l_id ; # Ich will erst mal ausgeben knnen wo eine Wste liegt, in welchem Land bzw. in welchen Lndern. SELECT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id ; Ich verstehe nicht warum es oben mehrere gleiche Ergebnisszeilen gibt, natrlich lassen sich die leicht entfernen: SELECT DISTINCT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id # Auerdem will ich diesen Zusammenhang fr alle 30 Wsten angezeigt haben, jetzt sind es aber pltzlich nur noch 2 ; SELECT DISTINCT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id GROUP BY ROLLUP(w.w_id, g.lt_id, lt.lt_id, l.l_id,w.name,w.flaeche,w.wuestenart,l.name) ORDER BY w.w_id, g.lt_id, lt.lt_id, l.l_id,w.name,w.flaeche,w.wuestenart,l.name # Ich glaube wir mssen da mit UNION arbeiten ... nee ... oder wie? ; SELECT DISTINCT w.w_id AS 创w.w_id创, g.lt_id AS 创g.lt_id创 , lt.lt_id AS 创lt.lt_id创, l.l_id AS 创l.l_id创, w.name AS 创w.name创, w.flaeche AS 创w.flaeche创, w.wuestenart AS 创w.wuestenart创, l.name AS 创l.name创 FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em><b><u>4.4.5</u></b> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=8.htm"
 onmouseover="show_text_in_form('Eine kleine Applikation \n1.  Implementieren Sie eine Webanfrageschnittstelle fr DB2 (hnlich der Schnittstelle \n die fr die Vorlesung DBS I eingesetzt wird). \n2.  Falls noch nicht geschehen, erweitern Sie die Schnittstelle so, da. auch Insert-, \n Update- und Delete-Ausdrcke verarbeitet werden knnen. Geben Sie dabei als \n Ausgabe die Anzahl der vernderten bzw. eingefgten/gelschten Tupel an.','SELECT * FROM BERG');"
 >SEL...</a> 
<a href="javascript:show_text_in_form('SELECT * FROM BERG','SELECT * FROM BERG');alert('Eine kleine Applikation \n1.  Implementieren Sie eine Webanfrageschnittstelle fr DB2 (hnlich der Schnittstelle \n die fr die Vorlesung DBS I eingesetzt wird). \n2.  Falls noch nicht geschehen, erweitern Sie die Schnittstelle so, da. auch Insert-, \n Update- und Delete-Ausdrcke verarbeitet werden knnen. Geben Sie dabei als \n Ausgabe die Anzahl der vernderten bzw. eingefgten/gelschten Tupel an.');"
 onmouseover="show_text_in_form('Eine kleine Applikation \n1.  Implementieren Sie eine Webanfrageschnittstelle fr DB2 (hnlich der Schnittstelle \n die fr die Vorlesung DBS I eingesetzt wird). \n2.  Falls noch nicht geschehen, erweitern Sie die Schnittstelle so, da. auch Insert-, \n Update- und Delete-Ausdrcke verarbeitet werden knnen. Geben Sie dabei als \n Ausgabe die Anzahl der vernderten bzw. eingefgten/gelschten Tupel an.','SELECT * FROM BERG');"
 
 onkeypress="'SELECT * FROM BERG'">Text</a></font><font size="+1"> <b><br>&#664</b> <b><u>GROUP und DISTINCT</u></b> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=9.htm"
 onmouseover="show_text_in_form('Und einmal ohne DISTINCT SELECT ...','SELECT * FROM berg WHERE gebirge < \'b\' ORDER BY gebirge ASC ; # DISTINCT entfernt doppelt Werte SELECT DISTINCT gebirge FROM berg WHERE gebirge < \'b\' ; # Obwohl hier die Ausgabe gleich wie die oben ist, gruppiert GROUP, # und ist damit nicht gleich DISTINCT\' , SELECT gebirge FROM berg GROUP BY gebirge ; SELECT GEBIRGE , COUNT(name) AS 创AnzahlBerge创, MAX(HOEHE ) 创Groester创 ,MIN(HOEHE ) 创Kleinster创, MAX(HOEHE )-MIN(HOEHE ) AS 创Unterschied创 FROM BERG GROUP BY GEBIRGE ORDER BY COUNT(name) DESC ; # Hier sieht man zustzlich eine Zeile die alle Gruppen zusammengefasst, als eine Gruppe behandelt. SELECT GEBIRGE , COUNT(name) AS 创AnzahlBerge创, MAX(HOEHE ) 创Groester创 ,MIN(HOEHE ) 创Kleinster创, MAX(HOEHE )-MIN(HOEHE ) AS 创Unterschied创 FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # ROLLUP GROUPING # Jetzt keine Verwechslunksgefahr mehr durch bessere Benennung. (Vgl. Null-Werte) SELECT GROUPING(GEBIRGE) AS 创GROUPING(gebirge)创 , CASE GROUPING(gebirge) WHEN 1 THEN \'(-alle Gebirge-)\' ELSE gebirge END AS 创CASE创 , GEBIRGE , COUNT(name) AS 创AnzahlBerge创, MAX(HOEHE ) 创Groester创 ,MIN(HOEHE ) 创Kleinster创, MAX(HOEHE )-MIN(HOEHE ) AS 创Unterschied创 FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # DISTINCT mehrspaltik</u></b> # DISTINCT sorgt hier nur fr einmalige Ergebniszeilen. Doppeltes wird gestrichen. # Vgl. einmal den SELECT nur ber die Spalte GEBIRGE SELECT gebirge, name FROM BERG ORDER BY gebirge');"
 >SEL...</a> 
<a href="javascript:show_text_in_form('SELECT * FROM berg WHERE gebirge < \'b\' ORDER BY gebirge ASC ; # DISTINCT entfernt doppelt Werte SELECT DISTINCT gebirge FROM berg WHERE gebirge < \'b\' ; # Obwohl hier die Ausgabe gleich wie die oben ist, gruppiert GROUP, # und ist damit nicht gleich DISTINCT\' , SELECT gebirge FROM berg GROUP BY gebirge ; SELECT GEBIRGE , COUNT(name) AS 创AnzahlBerge创, MAX(HOEHE ) 创Groester创 ,MIN(HOEHE ) 创Kleinster创, MAX(HOEHE )-MIN(HOEHE ) AS 创Unterschied创 FROM BERG GROUP BY GEBIRGE ORDER BY COUNT(name) DESC ; # Hier sieht man zustzlich eine Zeile die alle Gruppen zusammengefasst, als eine Gruppe behandelt. SELECT GEBIRGE , COUNT(name) AS 创AnzahlBerge创, MAX(HOEHE ) 创Groester创 ,MIN(HOEHE ) 创Kleinster创, MAX(HOEHE )-MIN(HOEHE ) AS 创Unterschied创 FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # ROLLUP GROUPING # Jetzt keine Verwechslunksgefahr mehr durch bessere Benennung. (Vgl. Null-Werte) SELECT GROUPING(GEBIRGE) AS 创GROUPING(gebirge)创 , CASE GROUPING(gebirge) WHEN 1 THEN \'(-alle Gebirge-)\' ELSE gebirge END AS 创CASE创 , GEBIRGE , COUNT(name) AS 创AnzahlBerge创, MAX(HOEHE ) 创Groester创 ,MIN(HOEHE ) 创Kleinster创, MAX(HOEHE )-MIN(HOEHE ) AS 创Unterschied创 FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # DISTINCT mehrspaltik</u></b> # DISTINCT sorgt hier nur fr einmalige Ergebniszeilen. Doppeltes wird gestrichen. # Vgl. einmal den SELECT nur ber die Spalte GEBIRGE SELECT gebirge, name FROM BERG ORDER BY gebirge','SELECT * FROM berg WHERE gebirge < \'b\' ORDER BY gebirge ASC ; # DISTINCT entfernt doppelt Werte SELECT DISTINCT gebirge FROM berg WHERE gebirge < \'b\' ; # Obwohl hier die Ausgabe gleich wie die oben ist, gruppiert GROUP, # und ist damit nicht gleich DISTINCT\' , SELECT gebirge FROM berg GROUP BY gebirge ; SELECT GEBIRGE , COUNT(name) AS 创AnzahlBerge创, MAX(HOEHE ) 创Groester创 ,MIN(HOEHE ) 创Kleinster创, MAX(HOEHE )-MIN(HOEHE ) AS 创Unterschied创 FROM BERG GROUP BY GEBIRGE ORDER BY COUNT(name) DESC ; # Hier sieht man zustzlich eine Zeile die alle Gruppen zusammengefasst, als eine Gruppe behandelt. SELECT GEBIRGE , COUNT(name) AS 创AnzahlBerge创, MAX(HOEHE ) 创Groester创 ,MIN(HOEHE ) 创Kleinster创, MAX(HOEHE )-MIN(HOEHE ) AS 创Unterschied创 FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # ROLLUP GROUPING # Jetzt keine Verwechslunksgefahr mehr durch bessere Benennung. (Vgl. Null-Werte) SELECT GROUPING(GEBIRGE) AS 创GROUPING(gebirge)创 , CASE GROUPING(gebirge) WHEN 1 THEN \'(-alle Gebirge-)\' ELSE gebirge END AS 创CASE创 , GEBIRGE , COUNT(name) AS 创AnzahlBerge创, MAX(HOEHE ) 创Groester创 ,MIN(HOEHE ) 创Kleinster创, MAX(HOEHE )-MIN(HOEHE ) AS 创Unterschied创 FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # DISTINCT mehrspaltik</u></b> # DISTINCT sorgt hier nur fr einmalige Ergebniszeilen. Doppeltes wird gestrichen. # Vgl. einmal den SELECT nur ber die Spalte GEBIRGE SELECT gebirge, name FROM BERG ORDER BY gebirge');alert('Und einmal ohne DISTINCT SELECT ...');"
 onmouseover="show_text_in_form('Und einmal ohne DISTINCT SELECT ...','SELECT * FROM berg WHERE gebirge < \'b\' ORDER BY gebirge ASC ; # DISTINCT entfernt doppelt Werte SELECT DISTINCT gebirge FROM berg WHERE gebirge < \'b\' ; # Obwohl hier die Ausgabe gleich wie die oben ist, gruppiert GROUP, # und ist damit nicht gleich DISTINCT\' , SELECT gebirge FROM berg GROUP BY gebirge ; SELECT GEBIRGE , COUNT(name) AS 创AnzahlBerge创, MAX(HOEHE ) 创Groester创 ,MIN(HOEHE ) 创Kleinster创, MAX(HOEHE )-MIN(HOEHE ) AS 创Unterschied创 FROM BERG GROUP BY GEBIRGE ORDER BY COUNT(name) DESC ; # Hier sieht man zustzlich eine Zeile die alle Gruppen zusammengefasst, als eine Gruppe behandelt. SELECT GEBIRGE , COUNT(name) AS 创AnzahlBerge创, MAX(HOEHE ) 创Groester创 ,MIN(HOEHE ) 创Kleinster创, MAX(HOEHE )-MIN(HOEHE ) AS 创Unterschied创 FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # ROLLUP GROUPING # Jetzt keine Verwechslunksgefahr mehr durch bessere Benennung. (Vgl. Null-Werte) SELECT GROUPING(GEBIRGE) AS 创GROUPING(gebirge)创 , CASE GROUPING(gebirge) WHEN 1 THEN \'(-alle Gebirge-)\' ELSE gebirge END AS 创CASE创 , GEBIRGE , COUNT(name) AS 创AnzahlBerge创, MAX(HOEHE ) 创Groester创 ,MIN(HOEHE ) 创Kleinster创, MAX(HOEHE )-MIN(HOEHE ) AS 创Unterschied创 FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # DISTINCT mehrspaltik</u></b> # DISTINCT sorgt hier nur fr einmalige Ergebniszeilen. Doppeltes wird gestrichen. # Vgl. einmal den SELECT nur ber die Spalte GEBIRGE SELECT gebirge, name FROM BERG ORDER BY gebirge');"
 
 onkeypress="'SELECT * FROM berg WHERE gebirge < \'b\' ORDER BY gebirge ASC ; # DISTINCT entfernt doppelt Werte SELECT DISTINCT gebirge FROM berg WHERE gebirge < \'b\' ; # Obwohl hier die Ausgabe gleich wie die oben ist, gruppiert GROUP, # und ist damit nicht gleich DISTINCT\' , SELECT gebirge FROM berg GROUP BY gebirge ; SELECT GEBIRGE , COUNT(name) AS 创AnzahlBerge创, MAX(HOEHE ) 创Groester创 ,MIN(HOEHE ) 创Kleinster创, MAX(HOEHE )-MIN(HOEHE ) AS 创Unterschied创 FROM BERG GROUP BY GEBIRGE ORDER BY COUNT(name) DESC ; # Hier sieht man zustzlich eine Zeile die alle Gruppen zusammengefasst, als eine Gruppe behandelt. SELECT GEBIRGE , COUNT(name) AS 创AnzahlBerge创, MAX(HOEHE ) 创Groester创 ,MIN(HOEHE ) 创Kleinster创, MAX(HOEHE )-MIN(HOEHE ) AS 创Unterschied创 FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # ROLLUP GROUPING # Jetzt keine Verwechslunksgefahr mehr durch bessere Benennung. (Vgl. Null-Werte) SELECT GROUPING(GEBIRGE) AS 创GROUPING(gebirge)创 , CASE GROUPING(gebirge) WHEN 1 THEN \'(-alle Gebirge-)\' ELSE gebirge END AS 创CASE创 , GEBIRGE , COUNT(name) AS 创AnzahlBerge创, MAX(HOEHE ) 创Groester创 ,MIN(HOEHE ) 创Kleinster创, MAX(HOEHE )-MIN(HOEHE ) AS 创Unterschied创 FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # DISTINCT mehrspaltik</u></b> # DISTINCT sorgt hier nur fr einmalige Ergebniszeilen. Doppeltes wird gestrichen. # Vgl. einmal den SELECT nur ber die Spalte GEBIRGE SELECT gebirge, name FROM BERG ORDER BY gebirge'">Text</a></font><font size="+1"> <b><br>&#664</b> <b><u>UNION(Vereinigung) INTERSECT(Schnittmenge) und EXCEPT(Minus)</u></b> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=10.htm"
 onmouseover="show_text_in_form('T1 UNION T2 \nVereinigung ohne doppelte Ergebnisse. \nErscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal.','# T1 UNION T2 # Vereinigung ohne doppelte Ergebnisse. # Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 UNION ALL T2 # Vereinigung. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie sogar 5-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT T2 # Schnittmenge ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT ALL T2 # Schnittmenge mit bei der kleinere Hufigkeit (wie bei UNION ALL) erhalten bleibt. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T2 EXCEPT T1 # Ergebnisse sind in T2, aber nicht in T1. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' ; # T1 EXCEPT T2 # Ergebnisse sind in T1, aber nicht in T2. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 EXCEPT ALL T2 # Differenz. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie genau 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC');"
 ># T...</a> 
<a href="javascript:show_text_in_form('# T1 UNION T2 # Vereinigung ohne doppelte Ergebnisse. # Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 UNION ALL T2 # Vereinigung. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie sogar 5-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT T2 # Schnittmenge ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT ALL T2 # Schnittmenge mit bei der kleinere Hufigkeit (wie bei UNION ALL) erhalten bleibt. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T2 EXCEPT T1 # Ergebnisse sind in T2, aber nicht in T1. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' ; # T1 EXCEPT T2 # Ergebnisse sind in T1, aber nicht in T2. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 EXCEPT ALL T2 # Differenz. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie genau 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC','# T1 UNION T2 # Vereinigung ohne doppelte Ergebnisse. # Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 UNION ALL T2 # Vereinigung. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie sogar 5-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT T2 # Schnittmenge ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT ALL T2 # Schnittmenge mit bei der kleinere Hufigkeit (wie bei UNION ALL) erhalten bleibt. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T2 EXCEPT T1 # Ergebnisse sind in T2, aber nicht in T1. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' ; # T1 EXCEPT T2 # Ergebnisse sind in T1, aber nicht in T2. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 EXCEPT ALL T2 # Differenz. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie genau 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC');alert('T1 UNION T2 \nVereinigung ohne doppelte Ergebnisse. \nErscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal.');"
 onmouseover="show_text_in_form('T1 UNION T2 \nVereinigung ohne doppelte Ergebnisse. \nErscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal.','# T1 UNION T2 # Vereinigung ohne doppelte Ergebnisse. # Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 UNION ALL T2 # Vereinigung. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie sogar 5-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT T2 # Schnittmenge ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT ALL T2 # Schnittmenge mit bei der kleinere Hufigkeit (wie bei UNION ALL) erhalten bleibt. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T2 EXCEPT T1 # Ergebnisse sind in T2, aber nicht in T1. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' ; # T1 EXCEPT T2 # Ergebnisse sind in T1, aber nicht in T2. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 EXCEPT ALL T2 # Differenz. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie genau 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC');"
 
 onkeypress="'# T1 UNION T2 # Vereinigung ohne doppelte Ergebnisse. # Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 UNION ALL T2 # Vereinigung. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie sogar 5-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT T2 # Schnittmenge ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT ALL T2 # Schnittmenge mit bei der kleinere Hufigkeit (wie bei UNION ALL) erhalten bleibt. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T2 EXCEPT T1 # Ergebnisse sind in T2, aber nicht in T1. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' ; # T1 EXCEPT T2 # Ergebnisse sind in T1, aber nicht in T2. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 EXCEPT ALL T2 # Differenz. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie genau 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC'">Text</a></font><font size="+1"> <b><br>&#664</b> <b><u>LEFT|RIGHT|FULL OUTER JOIN</u></b> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=11.htm"
 onmouseover="show_text_in_form('Der "normale" JOIN wird implizit im folgenden verwendet.','SELECT b.hoehe AS 创b.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e, berg AS b WHERE CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # JOIN # Hier wurde JOIN explizit verwendet. Das Ergebnis ist das selbe. SELECT b.hoehe AS 创b.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # LEFT OUTER JOIN # Zustzlich nun auch Zeilen linken Tabelle, welche die WHERE - Bedingung nicht erfllen. SELECT l.hoehe AS 创left.hoehe创 , b.hoehe AS 创b.hoehe创 FROM ebene AS l LEFT OUTER JOIN berg AS b ON CAST(l.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY l.hoehe ASC ; # RIGHT OUTER JOIN # Zustzlich nun auch Zeilen rechten Tabelle, # welche die WHERE - Bedingung nicht erfllen. SELECT right.hoehe AS 创right.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e RIGHT OUTER JOIN berg AS right ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(right.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC ; # FULL OUTER JOIN # Zustzlich nun auch Zeilen beider Tabellen, welche die WHERE - Bedingung nicht erfllen. SELECT b.hoehe AS 创b.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e FULL OUTER JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC');"
 >SEL...</a> 
<a href="javascript:show_text_in_form('SELECT b.hoehe AS 创b.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e, berg AS b WHERE CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # JOIN # Hier wurde JOIN explizit verwendet. Das Ergebnis ist das selbe. SELECT b.hoehe AS 创b.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # LEFT OUTER JOIN # Zustzlich nun auch Zeilen linken Tabelle, welche die WHERE - Bedingung nicht erfllen. SELECT l.hoehe AS 创left.hoehe创 , b.hoehe AS 创b.hoehe创 FROM ebene AS l LEFT OUTER JOIN berg AS b ON CAST(l.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY l.hoehe ASC ; # RIGHT OUTER JOIN # Zustzlich nun auch Zeilen rechten Tabelle, # welche die WHERE - Bedingung nicht erfllen. SELECT right.hoehe AS 创right.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e RIGHT OUTER JOIN berg AS right ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(right.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC ; # FULL OUTER JOIN # Zustzlich nun auch Zeilen beider Tabellen, welche die WHERE - Bedingung nicht erfllen. SELECT b.hoehe AS 创b.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e FULL OUTER JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC','SELECT b.hoehe AS 创b.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e, berg AS b WHERE CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # JOIN # Hier wurde JOIN explizit verwendet. Das Ergebnis ist das selbe. SELECT b.hoehe AS 创b.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # LEFT OUTER JOIN # Zustzlich nun auch Zeilen linken Tabelle, welche die WHERE - Bedingung nicht erfllen. SELECT l.hoehe AS 创left.hoehe创 , b.hoehe AS 创b.hoehe创 FROM ebene AS l LEFT OUTER JOIN berg AS b ON CAST(l.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY l.hoehe ASC ; # RIGHT OUTER JOIN # Zustzlich nun auch Zeilen rechten Tabelle, # welche die WHERE - Bedingung nicht erfllen. SELECT right.hoehe AS 创right.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e RIGHT OUTER JOIN berg AS right ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(right.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC ; # FULL OUTER JOIN # Zustzlich nun auch Zeilen beider Tabellen, welche die WHERE - Bedingung nicht erfllen. SELECT b.hoehe AS 创b.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e FULL OUTER JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC');alert('Der "normale" JOIN wird implizit im folgenden verwendet.');"
 onmouseover="show_text_in_form('Der "normale" JOIN wird implizit im folgenden verwendet.','SELECT b.hoehe AS 创b.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e, berg AS b WHERE CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # JOIN # Hier wurde JOIN explizit verwendet. Das Ergebnis ist das selbe. SELECT b.hoehe AS 创b.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # LEFT OUTER JOIN # Zustzlich nun auch Zeilen linken Tabelle, welche die WHERE - Bedingung nicht erfllen. SELECT l.hoehe AS 创left.hoehe创 , b.hoehe AS 创b.hoehe创 FROM ebene AS l LEFT OUTER JOIN berg AS b ON CAST(l.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY l.hoehe ASC ; # RIGHT OUTER JOIN # Zustzlich nun auch Zeilen rechten Tabelle, # welche die WHERE - Bedingung nicht erfllen. SELECT right.hoehe AS 创right.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e RIGHT OUTER JOIN berg AS right ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(right.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC ; # FULL OUTER JOIN # Zustzlich nun auch Zeilen beider Tabellen, welche die WHERE - Bedingung nicht erfllen. SELECT b.hoehe AS 创b.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e FULL OUTER JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC');"
 
 onkeypress="'SELECT b.hoehe AS 创b.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e, berg AS b WHERE CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # JOIN # Hier wurde JOIN explizit verwendet. Das Ergebnis ist das selbe. SELECT b.hoehe AS 创b.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # LEFT OUTER JOIN # Zustzlich nun auch Zeilen linken Tabelle, welche die WHERE - Bedingung nicht erfllen. SELECT l.hoehe AS 创left.hoehe创 , b.hoehe AS 创b.hoehe创 FROM ebene AS l LEFT OUTER JOIN berg AS b ON CAST(l.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY l.hoehe ASC ; # RIGHT OUTER JOIN # Zustzlich nun auch Zeilen rechten Tabelle, # welche die WHERE - Bedingung nicht erfllen. SELECT right.hoehe AS 创right.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e RIGHT OUTER JOIN berg AS right ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(right.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC ; # FULL OUTER JOIN # Zustzlich nun auch Zeilen beider Tabellen, welche die WHERE - Bedingung nicht erfllen. SELECT b.hoehe AS 创b.hoehe创, e.hoehe AS 创e.hoehe创 FROM ebene AS e FULL OUTER JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC'">Text</a></font><font size="+1"> <b>&#664</b> <u>Zufallszahlen - CREATE INSERT <b>WITH</b></u> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=12.htm"
 onmouseover="show_text_in_form('Tabelle mit Zufallszahlen erstellen.','CREATE TABLE zahlen(zhler Integer, zufall Integer) # Tabelle ist erstellt ; INSERT INTO zahlen(zhler, zufall) WITH temporre_Sicht(n) AS ( VALUES(1) UNION ALL SELECT n+1 FROM temporre_Sicht WHERE n<2 ) SELECT n, integer(rand()*10) FROM temporre_Sicht # Das hier ist der interessante Teil gewesen. ; SELECT * FROM zahlen; # Man sieht es hat geklappt. DROP TABLE zahlen;');"
 >CRE...</a> 
<a href="javascript:show_text_in_form('CREATE TABLE zahlen(zhler Integer, zufall Integer) # Tabelle ist erstellt ; INSERT INTO zahlen(zhler, zufall) WITH temporre_Sicht(n) AS ( VALUES(1) UNION ALL SELECT n+1 FROM temporre_Sicht WHERE n<2 ) SELECT n, integer(rand()*10) FROM temporre_Sicht # Das hier ist der interessante Teil gewesen. ; SELECT * FROM zahlen; # Man sieht es hat geklappt. DROP TABLE zahlen;','CREATE TABLE zahlen(zhler Integer, zufall Integer) # Tabelle ist erstellt ; INSERT INTO zahlen(zhler, zufall) WITH temporre_Sicht(n) AS ( VALUES(1) UNION ALL SELECT n+1 FROM temporre_Sicht WHERE n<2 ) SELECT n, integer(rand()*10) FROM temporre_Sicht # Das hier ist der interessante Teil gewesen. ; SELECT * FROM zahlen; # Man sieht es hat geklappt. DROP TABLE zahlen;');alert('Tabelle mit Zufallszahlen erstellen.');"
 onmouseover="show_text_in_form('Tabelle mit Zufallszahlen erstellen.','CREATE TABLE zahlen(zhler Integer, zufall Integer) # Tabelle ist erstellt ; INSERT INTO zahlen(zhler, zufall) WITH temporre_Sicht(n) AS ( VALUES(1) UNION ALL SELECT n+1 FROM temporre_Sicht WHERE n<2 ) SELECT n, integer(rand()*10) FROM temporre_Sicht # Das hier ist der interessante Teil gewesen. ; SELECT * FROM zahlen; # Man sieht es hat geklappt. DROP TABLE zahlen;');"
 
 onkeypress="'CREATE TABLE zahlen(zhler Integer, zufall Integer) # Tabelle ist erstellt ; INSERT INTO zahlen(zhler, zufall) WITH temporre_Sicht(n) AS ( VALUES(1) UNION ALL SELECT n+1 FROM temporre_Sicht WHERE n<2 ) SELECT n, integer(rand()*10) FROM temporre_Sicht # Das hier ist der interessante Teil gewesen. ; SELECT * FROM zahlen; # Man sieht es hat geklappt. DROP TABLE zahlen;'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em><u>2.3.4.2 <b>WITH</b></u> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=13.htm"
 onmouseover="show_text_in_form('2.3.4.2 \nGeben Sie alle Paare von Lndern mit Meereskste in Europa aus, die an die gleiche Menge von Meeren angrenzen. \nBeispiel: \n[Belgien, Niederlande] \nda M_Belgien = M_Niederlande = {Nordsee} \n[Belgien, Spanien] sollte nicht auftauchen, \nda M_Spanien = {Atlantik, Mittelmeer} \n','# Alle Lnder-Paare innerhalb Europa: WITH europa (l_id, l_name) AS ( SELECT l.l_id AS 创l.l_id创, l.name AS 创l.name创 FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ) SELECT l1.name 创l1.name创, l2.name 创l2.name创 FROM benachbart b, land l1, land l2 WHERE b.l_id1 = l1.l_id AND b.l_id2 = l2.l_id AND b.l_id1 IN (SELECT l_id FROM europa) AND b.l_id2 IN (SELECT l_id FROM europa) # ...57 Paare ; # Zuordnung Land und Meer: WITH land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l.name 创l.name创, m.name 创m.name创 FROM land_meer m, land l WHERE m.l_id = l.l_id ; # Eine mgliche Lsung: WITH europa (l_id,%20l_name%29%20as%20%28%20select%20l.l_id, l.name FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ), europa_paare (l_id1, l_id2) AS ( SELECT l_id1, l_id2 FROM benachbart b WHERE b.l_id1 IN ( SELECT l_id FROM europa )AND b.l_id2 IN ( SELECT l_id FROM europa ) ), land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l1.l_id 创l1.l_id创, l1.name 创l1.name创, l2.l_id 创l2.l_id创, l2.name 创l2.name创 FROM land l1, land l2, europa_paare e WHERE l1.l_id = e.l_id1 AND l2.l_id = e.l_id2 AND NOT EXISTS ( SELECT m1.name FROM land_meer m1 WHERE m1.l_id = e.l_id1 EXCEPT ALL SELECT m2.name FROM land_meer m2 WHERE m2.l_id = e.l_id2 ) AND NOT EXISTS ( SELECT m3.name FROM land_meer m3 WHERE m3.l_id = e.l_id2 EXCEPT ALL SELECT m4.name FROM land_meer m4 WHERE m4.l_id = e.l_id1 ) AND EXISTS ( SELECT m5.name FROM land_meer m5 WHERE m5.l_id = e.l_id1 )');"
 ># A...</a> 
<a href="javascript:show_text_in_form('# Alle Lnder-Paare innerhalb Europa: WITH europa (l_id, l_name) AS ( SELECT l.l_id AS 创l.l_id创, l.name AS 创l.name创 FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ) SELECT l1.name 创l1.name创, l2.name 创l2.name创 FROM benachbart b, land l1, land l2 WHERE b.l_id1 = l1.l_id AND b.l_id2 = l2.l_id AND b.l_id1 IN (SELECT l_id FROM europa) AND b.l_id2 IN (SELECT l_id FROM europa) # ...57 Paare ; # Zuordnung Land und Meer: WITH land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l.name 创l.name创, m.name 创m.name创 FROM land_meer m, land l WHERE m.l_id = l.l_id ; # Eine mgliche Lsung: WITH europa (l_id,%20l_name%29%20as%20%28%20select%20l.l_id, l.name FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ), europa_paare (l_id1, l_id2) AS ( SELECT l_id1, l_id2 FROM benachbart b WHERE b.l_id1 IN ( SELECT l_id FROM europa )AND b.l_id2 IN ( SELECT l_id FROM europa ) ), land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l1.l_id 创l1.l_id创, l1.name 创l1.name创, l2.l_id 创l2.l_id创, l2.name 创l2.name创 FROM land l1, land l2, europa_paare e WHERE l1.l_id = e.l_id1 AND l2.l_id = e.l_id2 AND NOT EXISTS ( SELECT m1.name FROM land_meer m1 WHERE m1.l_id = e.l_id1 EXCEPT ALL SELECT m2.name FROM land_meer m2 WHERE m2.l_id = e.l_id2 ) AND NOT EXISTS ( SELECT m3.name FROM land_meer m3 WHERE m3.l_id = e.l_id2 EXCEPT ALL SELECT m4.name FROM land_meer m4 WHERE m4.l_id = e.l_id1 ) AND EXISTS ( SELECT m5.name FROM land_meer m5 WHERE m5.l_id = e.l_id1 )','# Alle Lnder-Paare innerhalb Europa: WITH europa (l_id, l_name) AS ( SELECT l.l_id AS 创l.l_id创, l.name AS 创l.name创 FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ) SELECT l1.name 创l1.name创, l2.name 创l2.name创 FROM benachbart b, land l1, land l2 WHERE b.l_id1 = l1.l_id AND b.l_id2 = l2.l_id AND b.l_id1 IN (SELECT l_id FROM europa) AND b.l_id2 IN (SELECT l_id FROM europa) # ...57 Paare ; # Zuordnung Land und Meer: WITH land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l.name 创l.name创, m.name 创m.name创 FROM land_meer m, land l WHERE m.l_id = l.l_id ; # Eine mgliche Lsung: WITH europa (l_id,%20l_name%29%20as%20%28%20select%20l.l_id, l.name FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ), europa_paare (l_id1, l_id2) AS ( SELECT l_id1, l_id2 FROM benachbart b WHERE b.l_id1 IN ( SELECT l_id FROM europa )AND b.l_id2 IN ( SELECT l_id FROM europa ) ), land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l1.l_id 创l1.l_id创, l1.name 创l1.name创, l2.l_id 创l2.l_id创, l2.name 创l2.name创 FROM land l1, land l2, europa_paare e WHERE l1.l_id = e.l_id1 AND l2.l_id = e.l_id2 AND NOT EXISTS ( SELECT m1.name FROM land_meer m1 WHERE m1.l_id = e.l_id1 EXCEPT ALL SELECT m2.name FROM land_meer m2 WHERE m2.l_id = e.l_id2 ) AND NOT EXISTS ( SELECT m3.name FROM land_meer m3 WHERE m3.l_id = e.l_id2 EXCEPT ALL SELECT m4.name FROM land_meer m4 WHERE m4.l_id = e.l_id1 ) AND EXISTS ( SELECT m5.name FROM land_meer m5 WHERE m5.l_id = e.l_id1 )');alert('2.3.4.2 \nGeben Sie alle Paare von Lndern mit Meereskste in Europa aus, die an die gleiche Menge von Meeren angrenzen. \nBeispiel: \n[Belgien, Niederlande] \nda M_Belgien = M_Niederlande = {Nordsee} \n[Belgien, Spanien] sollte nicht auftauchen, \nda M_Spanien = {Atlantik, Mittelmeer} \n');"
 onmouseover="show_text_in_form('2.3.4.2 \nGeben Sie alle Paare von Lndern mit Meereskste in Europa aus, die an die gleiche Menge von Meeren angrenzen. \nBeispiel: \n[Belgien, Niederlande] \nda M_Belgien = M_Niederlande = {Nordsee} \n[Belgien, Spanien] sollte nicht auftauchen, \nda M_Spanien = {Atlantik, Mittelmeer} \n','# Alle Lnder-Paare innerhalb Europa: WITH europa (l_id, l_name) AS ( SELECT l.l_id AS 创l.l_id创, l.name AS 创l.name创 FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ) SELECT l1.name 创l1.name创, l2.name 创l2.name创 FROM benachbart b, land l1, land l2 WHERE b.l_id1 = l1.l_id AND b.l_id2 = l2.l_id AND b.l_id1 IN (SELECT l_id FROM europa) AND b.l_id2 IN (SELECT l_id FROM europa) # ...57 Paare ; # Zuordnung Land und Meer: WITH land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l.name 创l.name创, m.name 创m.name创 FROM land_meer m, land l WHERE m.l_id = l.l_id ; # Eine mgliche Lsung: WITH europa (l_id,%20l_name%29%20as%20%28%20select%20l.l_id, l.name FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ), europa_paare (l_id1, l_id2) AS ( SELECT l_id1, l_id2 FROM benachbart b WHERE b.l_id1 IN ( SELECT l_id FROM europa )AND b.l_id2 IN ( SELECT l_id FROM europa ) ), land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l1.l_id 创l1.l_id创, l1.name 创l1.name创, l2.l_id 创l2.l_id创, l2.name 创l2.name创 FROM land l1, land l2, europa_paare e WHERE l1.l_id = e.l_id1 AND l2.l_id = e.l_id2 AND NOT EXISTS ( SELECT m1.name FROM land_meer m1 WHERE m1.l_id = e.l_id1 EXCEPT ALL SELECT m2.name FROM land_meer m2 WHERE m2.l_id = e.l_id2 ) AND NOT EXISTS ( SELECT m3.name FROM land_meer m3 WHERE m3.l_id = e.l_id2 EXCEPT ALL SELECT m4.name FROM land_meer m4 WHERE m4.l_id = e.l_id1 ) AND EXISTS ( SELECT m5.name FROM land_meer m5 WHERE m5.l_id = e.l_id1 )');"
 
 onkeypress="'# Alle Lnder-Paare innerhalb Europa: WITH europa (l_id, l_name) AS ( SELECT l.l_id AS 创l.l_id创, l.name AS 创l.name创 FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ) SELECT l1.name 创l1.name创, l2.name 创l2.name创 FROM benachbart b, land l1, land l2 WHERE b.l_id1 = l1.l_id AND b.l_id2 = l2.l_id AND b.l_id1 IN (SELECT l_id FROM europa) AND b.l_id2 IN (SELECT l_id FROM europa) # ...57 Paare ; # Zuordnung Land und Meer: WITH land_meer (l_id, name) AS ( SELECT l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id = m.g_id GROUP BY l.l_id, g.name ) SELECT l.name 创l.name创, m.name 创m.name创 FROM land_meer m, land l WHERE m.l_id = l.l_id ; # Eine mgliche Lsung: WITH europa (l_id, l_name) AS ( SELECT l.l_id, l.name FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ), europa_paare (l_id1, l_id2) AS ( SELECT l_id1, l_id2 FROM benachbart b WHERE b.l_id1 IN ( SELECT l_id FROM europa )AND b.l_id2 IN ( SELECT l_id FROM europa ) ), land_meer (l_id, name) AS ( SELECT l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id = m.g_id GROUP BY l.l_id, g.name ) SELECT l1.l_id 创l1.l_id创, l1.name 创l1.name创, l2.l_id 创l2.l_id创, l2.name 创l2.name创 FROM land l1, land l2, europa_paare e WHERE l1.l_id = e.l_id1 AND l2.l_id = e.l_id2 AND NOT EXISTS ( SELECT m1.name FROM land_meer m1 WHERE m1.l_id = e.l_id1 EXCEPT ALL SELECT m2.name FROM land_meer m2 WHERE m2.l_id = e.l_id2 ) AND NOT EXISTS ( SELECT m3.name FROM land_meer m3 WHERE m3.l_id = e.l_id2 EXCEPT ALL SELECT m4.name FROM land_meer m4 WHERE m4.l_id = e.l_id1 ) AND EXISTS ( SELECT m5.name FROM land_meer m5 WHERE m5.l_id = e.l_id1 )'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em><u>2.3.4.3.(a) <b>WITH</b></u> billig von Kapstadt nach New York <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=14.htm"
 onmouseover="show_text_in_form('2.3.4.3.(a) \nFinden Sie die gnstigste Flugverbindung von Kapstadt nach New York.','# Theoretisch muss man alle mglichen Verbindungen durchrechnen, das ist bei einem rckgekoppelten Netz nicht mglich -> # Endlosschleife. # Daher wird hier die Zahl der Umstiegen wird auf 5 gesetzt. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Kapstadt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny # , flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id # _and f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'New_York\' AND umstieg < 5 ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 34 ->7 1 ->2 ->3 2 JFK 1673.00');"
 ># T...</a> 
<a href="javascript:show_text_in_form('# Theoretisch muss man alle mglichen Verbindungen durchrechnen, das ist bei einem rckgekoppelten Netz nicht mglich -> # Endlosschleife. # Daher wird hier die Zahl der Umstiegen wird auf 5 gesetzt. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Kapstadt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny # , flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id # _and f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'New_York\' AND umstieg < 5 ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 34 ->7 1 ->2 ->3 2 JFK 1673.00','# Theoretisch muss man alle mglichen Verbindungen durchrechnen, das ist bei einem rckgekoppelten Netz nicht mglich -> # Endlosschleife. # Daher wird hier die Zahl der Umstiegen wird auf 5 gesetzt. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Kapstadt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny # , flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id # _and f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'New_York\' AND umstieg < 5 ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 34 ->7 1 ->2 ->3 2 JFK 1673.00');alert('2.3.4.3.(a) \nFinden Sie die gnstigste Flugverbindung von Kapstadt nach New York.');"
 onmouseover="show_text_in_form('2.3.4.3.(a) \nFinden Sie die gnstigste Flugverbindung von Kapstadt nach New York.','# Theoretisch muss man alle mglichen Verbindungen durchrechnen, das ist bei einem rckgekoppelten Netz nicht mglich -> # Endlosschleife. # Daher wird hier die Zahl der Umstiegen wird auf 5 gesetzt. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Kapstadt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny # , flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id # _and f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'New_York\' AND umstieg < 5 ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 34 ->7 1 ->2 ->3 2 JFK 1673.00');"
 
 onkeypress="'# Theoretisch muss man alle mglichen Verbindungen durchrechnen, das ist bei einem rckgekoppelten Netz nicht mglich -> # Endlosschleife. # Daher wird hier die Zahl der Umstiegen wird auf 5 gesetzt. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Kapstadt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny # , flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id # _and f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'New_York\' AND umstieg < 5 ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 34 ->7 1 ->2 ->3 2 JFK 1673.00'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em><u>2.3.4.3.(b) <b>WITH</b></u> wenig Umstiege von Frankfurt nach Los Angeles <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=15.htm"
 onmouseover="show_text_in_form('2.3.4.3.(b) \nFinden Sie die Verbindung von Frankfurt nach Los Angeles mit den wenigsten \nUmstiegen. Falls mehrere Alternativen bestehen, whlen Sie die gnstigste.','# Die Abbruchbedingung aus der Rekursion kann man hier direkt angaben, da hier die Verbindung mit den wenigsten Umstiegen gesucht wird. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Frankfurt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny, flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id AND f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'Los_Angeles\' #AND umstieg < 5 */ ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 7 ->2 2 ->3 ->4 2 LAX 1920.00');"
 ># D...</a> 
<a href="javascript:show_text_in_form('# Die Abbruchbedingung aus der Rekursion kann man hier direkt angaben, da hier die Verbindung mit den wenigsten Umstiegen gesucht wird. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Frankfurt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny, flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id AND f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'Los_Angeles\' #AND umstieg < 5 */ ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 7 ->2 2 ->3 ->4 2 LAX 1920.00','# Die Abbruchbedingung aus der Rekursion kann man hier direkt angaben, da hier die Verbindung mit den wenigsten Umstiegen gesucht wird. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Frankfurt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny, flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id AND f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'Los_Angeles\' #AND umstieg < 5 */ ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 7 ->2 2 ->3 ->4 2 LAX 1920.00');alert('2.3.4.3.(b) \nFinden Sie die Verbindung von Frankfurt nach Los Angeles mit den wenigsten \nUmstiegen. Falls mehrere Alternativen bestehen, whlen Sie die gnstigste.');"
 onmouseover="show_text_in_form('2.3.4.3.(b) \nFinden Sie die Verbindung von Frankfurt nach Los Angeles mit den wenigsten \nUmstiegen. Falls mehrere Alternativen bestehen, whlen Sie die gnstigste.','# Die Abbruchbedingung aus der Rekursion kann man hier direkt angaben, da hier die Verbindung mit den wenigsten Umstiegen gesucht wird. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Frankfurt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny, flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id AND f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'Los_Angeles\' #AND umstieg < 5 */ ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 7 ->2 2 ->3 ->4 2 LAX 1920.00');"
 
 onkeypress="'# Die Abbruchbedingung aus der Rekursion kann man hier direkt angaben, da hier die Verbindung mit den wenigsten Umstiegen gesucht wird. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Frankfurt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny, flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id AND f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'Los_Angeles\' #AND umstieg < 5 */ ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 7 ->2 2 ->3 ->4 2 LAX 1920.00'">Text</a></font><form method="get"><table align="center" border="2" cellpadding="2" cellspacing="0" bordercolor="#ffff00"><tr><td><em>&nbsp;&nbsp;SQL-Befehl fuer DB2</em>&nbsp;&nbsp;&nbsp;&nbsp;<input type="Submit" accesskey="1" value="SQL senden (ALT+1)" onmouseover="load_backup();"  onclick="load_backup();" " >
	<a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20stadt&table_name=stadt.htm">SELECT * FROM stadt</a>
	<br><textarea name="sql" cols="100" rows="3"  onclick="load_backup();" "  onmouseover="load_backup();"  onchange="set_backup();"  onfocus="this.select();" "  accesskey="2">SELECT S.stadt AS "S.stadt", S.land AS "S.land" 
FROM STADT AS S
                                                                             ; # focus hier ALT+2
# Die Standard SELECTS * oben, erhllt man auch ber
# ALT+(Erster Buchstabe der Tabelle.)+ENTER 
# odbc_num_rows: Syntax-Fehler ,  odbc_num_fields: Syntax-Fehler</textarea></td></tr></table>odbc_exec misslungen! (<font size=-3></font>)<table border="1" cellspacing="0" cellpadding="0" width="100%"><tr><td valign="top" bgcolor="#FFFFFF" nowrap><font color="Black"><font size="-1"><br><font size="-2"><a href="" target="o"></a></font></font></td></tr><tr><td bgcolor="#FFCC99" width="100%"><font color="Black">SELECT S.stadt AS "S.stadt", S.land AS "S.land" <br>
FROM STADT AS S<br>
[IBM][CLI Driver][DB2/NT] SQL0206N&nbsp; "S.STADT" ist in dem verwendeten Kontext ungltig.&nbsp; SQLSTATE=42703<br>
</font></td></tr></table><form name="f1111000845"><input type="Button" style="font-size: 9px; color: black; border: 0px White; background: White;" name="f1111000845" value="Jump"></form><script language="JavaScript">
         document.forms["f1111000845"].elements["f1111000845"].focus();
         </script><table border="5" cellspacing="0" cellpadding="0" width="100%"><tr><td valign="top" bgcolor="#FFFFFF" nowrap><font color="Black"><font size="-1">&nbsp;&nbsp;<b>Anzahl</b> der <u>vernderten</u> bzw. <u>eingefgten</u> / <u>gelschten</u> Tupel:&nbsp;<br><font size="-2"><a href="" target="o"></a></font></font></td><td bgcolor="#ffffff" width="100%"><font color="Black">&nbsp;&nbsp;<b>Syntax-Fehler</b>&nbsp;&nbsp;(<font size=-2>odbc_num_rows(  )=<b>Syntax-Fehler</b> odbc_num_fields(  )=<b>Syntax-Fehler</b></font>)</font></td></tr></table></table></form><br></body></html>