<html><head>
<style type="text/css"> 
A 					{ font-size: 11pt; text-decoration: none; } 
A:Hover, A:Active 	{ font-size: 12pt; text-decoration: underline; color: black; }
</style>
<script language="JavaScript">
var backup_text, text_is_sql = true;
function show_text_in_form(t , s ){	
	set_backup();
	document.forms[0].elements['sql'].value = t; 
	text_is_sql = false;
	window.status = s;
	//alert(s);
}
function load_backup(){ 
	if(!text_is_sql && backup_text){
		document.forms[0].elements['sql'].value = backup_text; 
		text_is_sql = true;
	}
	//alert('load_backup'); 
}
function set_backup(){	
	if(text_is_sql) {
		with (document.forms[0].elements['sql'] ) {
			if( value ){ backup_text = value; text_is_sql = true; }
		}
	}
	//alert('set_backup'); 
}
function on_load(){	set_backup(); }
</script>
</head><body onload="on_load()">
<font size="-1">Aufgabe 4.4.5 Eine kleine Applikation</font> - 
odbc_connect ok! (<font size=-3>Resource id #2</font>)<br>SELECT * FROM <font size="-1"><a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20benachbart&table_name=benachbart.htm" accesskey="b">benachbart</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20berg&table_name=berg.htm" accesskey="b">berg</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20ebene&table_name=ebene.htm" accesskey="e">ebene</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20flug&table_name=flug.htm" accesskey="f">flug</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20flughafen&table_name=flughafen.htm" accesskey="f">flughafen</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20fluss&table_name=fluss.htm" accesskey="f">fluss</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20flussquelle&table_name=flussquelle.htm" accesskey="f">flussquelle</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20gehoert_lt&table_name=gehoert_lt.htm" accesskey="g">gehoert_lt</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20geht_ueber&table_name=geht_ueber.htm" accesskey="g">geht_ueber</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20geo_berg&table_name=geo_berg.htm" accesskey="g">geo_berg</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20geo_ebene&table_name=geo_ebene.htm" accesskey="g">geo_ebene</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20geo_gewaesser&table_name=geo_gewaesser.htm" accesskey="g">geo_gewaesser</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20geo_insel&table_name=geo_insel.htm" accesskey="g">geo_insel</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20geo_wueste&table_name=geo_wueste.htm" accesskey="g">geo_wueste</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20gewaesser&table_name=gewaesser.htm" accesskey="g">gewaesser</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20hat_sitz_in&table_name=hat_sitz_in.htm" accesskey="h">hat_sitz_in</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20insel&table_name=insel.htm" accesskey="i">insel</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20ist_mitglied&table_name=ist_mitglied.htm" accesskey="i">ist_mitglied</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20kontinent&table_name=kontinent.htm" accesskey="k">kontinent</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20land&table_name=land.htm" accesskey="l">land</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20landesteil&table_name=landesteil.htm" accesskey="l">landesteil</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20liegt_an&table_name=liegt_an.htm" accesskey="l">liegt_an</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20meer&table_name=meer.htm" accesskey="m">meer</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20muendet&table_name=muendet.htm" accesskey="m">muendet</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20organisation&table_name=organisation.htm" accesskey="o">organisation</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20see&table_name=see.htm" accesskey="s">see</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20stadt&table_name=stadt.htm" accesskey="s">stadt</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20test&table_name=test.htm" accesskey="t">test</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20umfasst&table_name=umfasst.htm" accesskey="u">umfasst</a> <a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20wueste&table_name=wueste.htm" accesskey="w">wueste</a> <hr><font size="+1"> <b>&#664</b> <em>Aufg.</em><b><u>2.3.3.1</u></b> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=1.htm"
 onmouseover="show_text_in_form('Geben Sie alle Städte an, die ungefähr 100.000 Einwohner haben. \nSortieren Sie die Städte  \nnach der Abweichung von dieser Einwohnerzahl  \n(Städte mit kleinerer Abweichung stehen weiter vorne in der Liste). \n \nGeben Sie alle Städte an, die um maximal 10.000 Einwohner von 100.000 Einwohnern abweichen.','SELECT name, einwohner, ABS( einwohner - 100000 ) AS abweichung FROM STADT WHERE einwohner + 10000 >= 100000 AND einwohner - 10000 <= 100000 ORDER BY ABS( einwohner - 100000 )');"
 >SEL...</a> 
<a href="javascript:show_text_in_form('SELECT name, einwohner, ABS( einwohner - 100000 ) AS abweichung FROM STADT WHERE einwohner + 10000 >= 100000 AND einwohner - 10000 <= 100000 ORDER BY ABS( einwohner - 100000 )','SELECT name, einwohner, ABS( einwohner - 100000 ) AS abweichung FROM STADT WHERE einwohner + 10000 >= 100000 AND einwohner - 10000 <= 100000 ORDER BY ABS( einwohner - 100000 )');alert('Geben Sie alle Städte an, die ungefähr 100.000 Einwohner haben. \nSortieren Sie die Städte  \nnach der Abweichung von dieser Einwohnerzahl  \n(Städte mit kleinerer Abweichung stehen weiter vorne in der Liste). \n \nGeben Sie alle Städte an, die um maximal 10.000 Einwohner von 100.000 Einwohnern abweichen.');"
 onmouseover="show_text_in_form('Geben Sie alle Städte an, die ungefähr 100.000 Einwohner haben. \nSortieren Sie die Städte  \nnach der Abweichung von dieser Einwohnerzahl  \n(Städte mit kleinerer Abweichung stehen weiter vorne in der Liste). \n \nGeben Sie alle Städte an, die um maximal 10.000 Einwohner von 100.000 Einwohnern abweichen.','SELECT name, einwohner, ABS( einwohner - 100000 ) AS abweichung FROM STADT WHERE einwohner + 10000 >= 100000 AND einwohner - 10000 <= 100000 ORDER BY ABS( einwohner - 100000 )');"
 
 onkeypress="'SELECT name, einwohner, ABS( einwohner - 100000 ) AS abweichung FROM STADT WHERE einwohner + 10000 >= 100000 AND einwohner - 10000 <= 100000 ORDER BY ABS( einwohner - 100000 )'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em><b><u>2.3.3.2</u> Ähnlichkeit mittels LOCATE|SOUNDEX|DIFFERENCE</b> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=2.htm"
 onmouseover="show_text_in_form('Geben Sie alle Länder an, deren Hauptstadtname Ähnlichkeit mit dem Landesnamen hat. \nDie Lösung ganz am Ende mit DIFFERENCE gefällt mir am besten. \n','SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlänge , length( RTRIM(l.name) ) AS Landlänge FROM land l, stadt s ### LOCATE( s1, s2 ) -> Integer ### gibt die Position des ersten Auftauchens von String s2 in String s1 an. WHERE l.hauptstadt = s.s_id AND ( LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 OR LOCATE(RTRIM(l.name), RTRIM( s.name)) > 0 ) ; ### Zur Verdeutlichung einmal nur das enthaltensein von Stadtnamen im Landesnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlänge , length( RTRIM(l.name) ) AS Landlänge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 ; ### Und noch einmal umgekehrt, das enthaltensein von Landesnamen im Stadtnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlänge , length( RTRIM(l.name) ) AS Landlänge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE( RTRIM( l.name) , RTRIM(s.name) ) > 0 ; ### Alternative Lösung mit Funktion SOUNDEX() SELECT s.name AS Stadt, l.name AS Land FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND SOUNDEX(s.name) = SOUNDEX(l.name); ### Alternative Lösung mit Funktion DIFFERENCE( s1, s2 ) Klangübereinstimmung zw. 0 und 4 SELECT s.name AS Stadt, l.name AS Land, DIFFERENCE( s.name , l.name ) as Klangübereinstimmung FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND DIFFERENCE( s.name , l.name ) > 2 ORDER BY Klangübereinstimmung DESC ;');"
 >SEL...</a> 
<a href="javascript:show_text_in_form('SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlänge , length( RTRIM(l.name) ) AS Landlänge FROM land l, stadt s ### LOCATE( s1, s2 ) -> Integer ### gibt die Position des ersten Auftauchens von String s2 in String s1 an. WHERE l.hauptstadt = s.s_id AND ( LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 OR LOCATE(RTRIM(l.name), RTRIM( s.name)) > 0 ) ; ### Zur Verdeutlichung einmal nur das enthaltensein von Stadtnamen im Landesnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlänge , length( RTRIM(l.name) ) AS Landlänge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 ; ### Und noch einmal umgekehrt, das enthaltensein von Landesnamen im Stadtnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlänge , length( RTRIM(l.name) ) AS Landlänge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE( RTRIM( l.name) , RTRIM(s.name) ) > 0 ; ### Alternative Lösung mit Funktion SOUNDEX() SELECT s.name AS Stadt, l.name AS Land FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND SOUNDEX(s.name) = SOUNDEX(l.name); ### Alternative Lösung mit Funktion DIFFERENCE( s1, s2 ) Klangübereinstimmung zw. 0 und 4 SELECT s.name AS Stadt, l.name AS Land,%20difference%28%20s.name , l.name ) as Klangübereinstimmung FROM land l,%20stadt%20s%20where%20l.hauptstadt%20=%20s.s_id%20and%20difference%28%20s.name , l.name ) > 2 ORDER BY Klangübereinstimmung DESC ;','SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlänge , length( RTRIM(l.name) ) AS Landlänge FROM land l, stadt s ### LOCATE( s1, s2 ) -> Integer ### gibt die Position des ersten Auftauchens von String s2 in String s1 an. WHERE l.hauptstadt = s.s_id AND ( LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 OR LOCATE(RTRIM(l.name), RTRIM( s.name)) > 0 ) ; ### Zur Verdeutlichung einmal nur das enthaltensein von Stadtnamen im Landesnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlänge , length( RTRIM(l.name) ) AS Landlänge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 ; ### Und noch einmal umgekehrt, das enthaltensein von Landesnamen im Stadtnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlänge , length( RTRIM(l.name) ) AS Landlänge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE( RTRIM( l.name) , RTRIM(s.name) ) > 0 ; ### Alternative Lösung mit Funktion SOUNDEX() SELECT s.name AS Stadt, l.name AS Land FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND SOUNDEX(s.name) = SOUNDEX(l.name); ### Alternative Lösung mit Funktion DIFFERENCE( s1, s2 ) Klangübereinstimmung zw. 0 und 4 SELECT s.name AS Stadt, l.name AS Land,%20difference%28%20s.name , l.name ) as Klangübereinstimmung FROM land l,%20stadt%20s%20where%20l.hauptstadt%20=%20s.s_id%20and%20difference%28%20s.name , l.name ) > 2 ORDER BY Klangübereinstimmung DESC ;');alert('Geben Sie alle Länder an, deren Hauptstadtname Ähnlichkeit mit dem Landesnamen hat. \nDie Lösung ganz am Ende mit DIFFERENCE gefällt mir am besten. \n');"
 onmouseover="show_text_in_form('Geben Sie alle Länder an, deren Hauptstadtname Ähnlichkeit mit dem Landesnamen hat. \nDie Lösung ganz am Ende mit DIFFERENCE gefällt mir am besten. \n','SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlänge , length( RTRIM(l.name) ) AS Landlänge FROM land l, stadt s ### LOCATE( s1, s2 ) -> Integer ### gibt die Position des ersten Auftauchens von String s2 in String s1 an. WHERE l.hauptstadt = s.s_id AND ( LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 OR LOCATE(RTRIM(l.name), RTRIM( s.name)) > 0 ) ; ### Zur Verdeutlichung einmal nur das enthaltensein von Stadtnamen im Landesnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlänge , length( RTRIM(l.name) ) AS Landlänge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 ; ### Und noch einmal umgekehrt, das enthaltensein von Landesnamen im Stadtnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlänge , length( RTRIM(l.name) ) AS Landlänge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE( RTRIM( l.name) , RTRIM(s.name) ) > 0 ; ### Alternative Lösung mit Funktion SOUNDEX() SELECT s.name AS Stadt, l.name AS Land FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND SOUNDEX(s.name) = SOUNDEX(l.name); ### Alternative Lösung mit Funktion DIFFERENCE( s1, s2 ) Klangübereinstimmung zw. 0 und 4 SELECT s.name AS Stadt, l.name AS Land, DIFFERENCE( s.name , l.name ) as Klangübereinstimmung FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND DIFFERENCE( s.name , l.name ) > 2 ORDER BY Klangübereinstimmung DESC ;');"
 
 onkeypress="'SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlänge , length( RTRIM(l.name) ) AS Landlänge FROM land l, stadt s ### LOCATE( s1, s2 ) -> Integer ### gibt die Position des ersten Auftauchens von String s2 in String s1 an. WHERE l.hauptstadt = s.s_id AND ( LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 OR LOCATE(RTRIM(l.name), RTRIM( s.name)) > 0 ) ; ### Zur Verdeutlichung einmal nur das enthaltensein von Stadtnamen im Landesnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlänge , length( RTRIM(l.name) ) AS Landlänge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE(RTRIM(s.name), RTRIM( l.name)) > 0 ; ### Und noch einmal umgekehrt, das enthaltensein von Landesnamen im Stadtnamen SELECT s.name AS Stadt, l.name AS Land , length( RTRIM(s.name) ) AS Stadtlänge , length( RTRIM(l.name) ) AS Landlänge FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND LOCATE( RTRIM( l.name) , RTRIM(s.name) ) > 0 ; ### Alternative Lösung mit Funktion SOUNDEX() SELECT s.name AS Stadt, l.name AS Land FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND SOUNDEX(s.name) = SOUNDEX(l.name); ### Alternative Lösung mit Funktion DIFFERENCE( s1, s2 ) Klangübereinstimmung zw. 0 und 4 SELECT s.name AS Stadt, l.name AS Land, DIFFERENCE( s.name , l.name ) as Klangübereinstimmung FROM land l, stadt s WHERE l.hauptstadt = s.s_id AND DIFFERENCE( s.name , l.name ) > 2 ORDER BY Klangübereinstimmung DESC ;'">Text</a></font><font size="+1"> <b>&#664</b> INSERT .. MAX(S_ID) <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=3.htm"
 onmouseover="show_text_in_form('Insert in eine Tabelle.','INSERT INTO stadt ( s_id, name, einwohner ) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 12345 ); SELECT * FROM stadt WHERE S_ID > 629; DELETE FROM STADT WHERE S_ID > 629');"
 >INS...</a> 
<a href="javascript:show_text_in_form('INSERT INTO stadt ( s_id, name, einwohner ) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 12345 ); SELECT * FROM stadt WHERE S_ID > 629; DELETE FROM STADT WHERE S_ID > 629','INSERT INTO stadt ( s_id, name, einwohner ) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 12345 ); SELECT * FROM stadt WHERE S_ID > 629; DELETE FROM STADT WHERE S_ID > 629');alert('Insert in eine Tabelle.');"
 onmouseover="show_text_in_form('Insert in eine Tabelle.','INSERT INTO stadt ( s_id, name, einwohner ) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 12345 ); SELECT * FROM stadt WHERE S_ID > 629; DELETE FROM STADT WHERE S_ID > 629');"
 
 onkeypress="'INSERT INTO stadt ( s_id, name, einwohner ) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 12345 ); SELECT * FROM stadt WHERE S_ID > 629; DELETE FROM STADT WHERE S_ID > 629'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em><b><u>2.3.3.3 a), b), c), d), e), f)</u></b> &nbsp;VIEW <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=4.htm"
 onmouseover="show_text_in_form('Erzeugen Sie mit einer Sicht einen Auschnitt der Relation Stadt,  \nin der alle Städte mit mehr als fünf Millionen Einwohnern eingetragen sind.  \nÜbernehmen Sie in die Sicht die Attribute S ID, Name und Einwohner.  \n \nWeitere Teilaufgaben zwischen dem SQL- Befehl formuliert. \nBeschreiben Sie für die folgenden Operationen jeweils die Reaktionen des Datenbanksystems: \n','CREATE VIEW stadtview ( s_id, name, einwohner) AS SELECT s_id, name, einwohner FROM stadt WHERE einwohner > 10000000; # Die Sicht ist erzeugt, jetzt wollen doch mal sehen was so drin steckt. SELECT * FROM stadtview; # 2.3.3.3 a) Stadt in Sicht mit mehr als fünf Millionen Einwohnern einfügen und ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview), \'TestStadt\', 10000001 ); SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id # Interessant ist, das der eben eingefügte Datensatz zweimal angezeigt wird. # Man sieht (vielleicht überraschend) dass der Datensatz in Tabelle stadt eingefügt wurde. # obwohl der insert_ eindeutig in die view einfügt. ; # 2.3.3.3 b) DELETE FROM stadtview WHERE name = \'TestStadt\' # Wir werden gleich sehen, das sich dieses löschen # wieder auf die Tabelle ausgwirkte. Im View ist der Eintrag auch nicht mehr zu finden. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 c) # Fügen Sie eine Stadt mit weniger als fünf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht und die Relation Stadt ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 11 ) # Wir werden sehen, dieser neue Datensatz erstens wieder in Tabelle stadt # eingefügt wurde und zweitens in stadtview nicht mehr auftaucht, ganz gemäß # der Bedinungen des VIEWS bezüglich der Einwohnerzahl. Fein :) # Also alles so wie es sein sollte. Der VIEW bleibt stimmig. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 d) # Fügen Sie die Stadt erneut mit mehr als fünf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 10000002 ) # Interessant hier gibt es eine Fehlermeldung, weil dieser Index für den letzten Einfug in stadt # verwendet wurde, also belegt ist. # Dies wird nicht erkannt bzw. berücksichtig, da letzer Einfug nicht im VIEW vermerkt ist. ; SELECT MAX(v.S_ID)+99 AS ´´MAX(v.S_ID)+99´´, MAX(v.S_ID) AS ´´MAX(v.S_ID)´´, MAX(s.S_ID)+99 AS ´´MAX(s.S_ID)+99´´, MAX(s.S_ID) AS ´´MAX(s.S_ID)´´ FROM stadtview AS v, stadt AS s ; INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 10000002 ) ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 e) # Löschen Sie die Stadt aus der Sicht. DELETE FROM stadtview WHERE einwohner = 10000002 ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 f) # Löschen Sie die Stadt aus der Relation Stadt. DELETE FROM stadt WHERE einwohner = 10000002 # Klar, wir wissen ja, das hat auswirkungen auf VIEWs und RELATION ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # Und wieder löschen, für den nächsten Versuch :) DROP VIEW stadtview; DELETE FROM STADT WHERE S_ID > 629;');"
 >CRE...</a> 
<a href="javascript:show_text_in_form('CREATE VIEW stadtview ( s_id, name, einwohner) AS SELECT s_id, name, einwohner FROM stadt WHERE einwohner > 10000000; # Die Sicht ist erzeugt, jetzt wollen doch mal sehen was so drin steckt. SELECT * FROM stadtview; # 2.3.3.3 a) Stadt in Sicht mit mehr als fünf Millionen Einwohnern einfügen und ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview), \'TestStadt\', 10000001 ); SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id # Interessant ist, das der eben eingefügte Datensatz zweimal angezeigt wird. # Man sieht (vielleicht überraschend) dass der Datensatz in Tabelle stadt eingefügt wurde. # obwohl der insert_ eindeutig in die view einfügt. ; # 2.3.3.3 b) DELETE FROM stadtview WHERE name = \'TestStadt\' # Wir werden gleich sehen, das sich dieses löschen # wieder auf die Tabelle ausgwirkte. Im View ist der Eintrag auch nicht mehr zu finden. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 c) # Fügen Sie eine Stadt mit weniger als fünf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht und die Relation Stadt ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 11 ) # Wir werden sehen, dieser neue Datensatz erstens wieder in Tabelle stadt # eingefügt wurde und zweitens in stadtview nicht mehr auftaucht, ganz gemäß # der Bedinungen des VIEWS bezüglich der Einwohnerzahl. Fein :) # Also alles so wie es sein sollte. Der VIEW bleibt stimmig. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 d) # Fügen Sie die Stadt erneut mit mehr als fünf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 10000002 ) # Interessant hier gibt es eine Fehlermeldung, weil dieser Index für den letzten Einfug in stadt # verwendet wurde, also belegt ist. # Dies wird nicht erkannt bzw. berücksichtig, da letzer Einfug nicht im VIEW vermerkt ist. ; SELECT MAX(v.S_ID)+99 AS ´´MAX(v.S_ID)+99´´, MAX(v.S_ID) AS ´´MAX(v.S_ID)´´, MAX(s.S_ID)+99 AS ´´MAX(s.S_ID)+99´´, MAX(s.S_ID) AS ´´MAX(s.S_ID)´´ FROM stadtview AS v, stadt AS s ; INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 10000002 ) ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 e) # Löschen Sie die Stadt aus der Sicht. DELETE FROM stadtview WHERE einwohner = 10000002 ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 f) # Löschen Sie die Stadt aus der Relation Stadt. DELETE FROM stadt WHERE einwohner = 10000002 # Klar, wir wissen ja, das hat auswirkungen auf VIEWs und RELATION ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # Und wieder löschen, für den nächsten Versuch :) DROP VIEW stadtview; DELETE FROM STADT WHERE S_ID > 629;','CREATE VIEW stadtview ( s_id, name, einwohner) AS SELECT s_id, name, einwohner FROM stadt WHERE einwohner > 10000000; # Die Sicht ist erzeugt, jetzt wollen doch mal sehen was so drin steckt. SELECT * FROM stadtview; # 2.3.3.3 a) Stadt in Sicht mit mehr als fünf Millionen Einwohnern einfügen und ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview), \'TestStadt\', 10000001 ); SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id # Interessant ist, das der eben eingefügte Datensatz zweimal angezeigt wird. # Man sieht (vielleicht überraschend) dass der Datensatz in Tabelle stadt eingefügt wurde. # obwohl der insert_ eindeutig in die view einfügt. ; # 2.3.3.3 b) DELETE FROM stadtview WHERE name = \'TestStadt\' # Wir werden gleich sehen, das sich dieses löschen # wieder auf die Tabelle ausgwirkte. Im View ist der Eintrag auch nicht mehr zu finden. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 c) # Fügen Sie eine Stadt mit weniger als fünf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht und die Relation Stadt ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 11 ) # Wir werden sehen, dieser neue Datensatz erstens wieder in Tabelle stadt # eingefügt wurde und zweitens in stadtview nicht mehr auftaucht, ganz gemäß # der Bedinungen des VIEWS bezüglich der Einwohnerzahl. Fein :) # Also alles so wie es sein sollte. Der VIEW bleibt stimmig. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 d) # Fügen Sie die Stadt erneut mit mehr als fünf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 10000002 ) # Interessant hier gibt es eine Fehlermeldung, weil dieser Index für den letzten Einfug in stadt # verwendet wurde, also belegt ist. # Dies wird nicht erkannt bzw. berücksichtig, da letzer Einfug nicht im VIEW vermerkt ist. ; SELECT MAX(v.S_ID)+99 AS ´´MAX(v.S_ID)+99´´, MAX(v.S_ID) AS ´´MAX(v.S_ID)´´, MAX(s.S_ID)+99 AS ´´MAX(s.S_ID)+99´´, MAX(s.S_ID) AS ´´MAX(s.S_ID)´´ FROM stadtview AS v, stadt AS s ; INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 10000002 ) ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 e) # Löschen Sie die Stadt aus der Sicht. DELETE FROM stadtview WHERE einwohner = 10000002 ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 f) # Löschen Sie die Stadt aus der Relation Stadt. DELETE FROM stadt WHERE einwohner = 10000002 # Klar, wir wissen ja, das hat auswirkungen auf VIEWs und RELATION ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # Und wieder löschen, für den nächsten Versuch :) DROP VIEW stadtview; DELETE FROM STADT WHERE S_ID > 629;');alert('Erzeugen Sie mit einer Sicht einen Auschnitt der Relation Stadt,  \nin der alle Städte mit mehr als fünf Millionen Einwohnern eingetragen sind.  \nÜbernehmen Sie in die Sicht die Attribute S ID, Name und Einwohner.  \n \nWeitere Teilaufgaben zwischen dem SQL- Befehl formuliert. \nBeschreiben Sie für die folgenden Operationen jeweils die Reaktionen des Datenbanksystems: \n');"
 onmouseover="show_text_in_form('Erzeugen Sie mit einer Sicht einen Auschnitt der Relation Stadt,  \nin der alle Städte mit mehr als fünf Millionen Einwohnern eingetragen sind.  \nÜbernehmen Sie in die Sicht die Attribute S ID, Name und Einwohner.  \n \nWeitere Teilaufgaben zwischen dem SQL- Befehl formuliert. \nBeschreiben Sie für die folgenden Operationen jeweils die Reaktionen des Datenbanksystems: \n','CREATE VIEW stadtview ( s_id, name, einwohner) AS SELECT s_id, name, einwohner FROM stadt WHERE einwohner > 10000000; # Die Sicht ist erzeugt, jetzt wollen doch mal sehen was so drin steckt. SELECT * FROM stadtview; # 2.3.3.3 a) Stadt in Sicht mit mehr als fünf Millionen Einwohnern einfügen und ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview), \'TestStadt\', 10000001 ); SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id # Interessant ist, das der eben eingefügte Datensatz zweimal angezeigt wird. # Man sieht (vielleicht überraschend) dass der Datensatz in Tabelle stadt eingefügt wurde. # obwohl der insert_ eindeutig in die view einfügt. ; # 2.3.3.3 b) DELETE FROM stadtview WHERE name = \'TestStadt\' # Wir werden gleich sehen, das sich dieses löschen # wieder auf die Tabelle ausgwirkte. Im View ist der Eintrag auch nicht mehr zu finden. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 c) # Fügen Sie eine Stadt mit weniger als fünf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht und die Relation Stadt ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 11 ) # Wir werden sehen, dieser neue Datensatz erstens wieder in Tabelle stadt # eingefügt wurde und zweitens in stadtview nicht mehr auftaucht, ganz gemäß # der Bedinungen des VIEWS bezüglich der Einwohnerzahl. Fein :) # Also alles so wie es sein sollte. Der VIEW bleibt stimmig. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 d) # Fügen Sie die Stadt erneut mit mehr als fünf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 10000002 ) # Interessant hier gibt es eine Fehlermeldung, weil dieser Index für den letzten Einfug in stadt # verwendet wurde, also belegt ist. # Dies wird nicht erkannt bzw. berücksichtig, da letzer Einfug nicht im VIEW vermerkt ist. ; SELECT MAX(v.S_ID)+99 AS ´´MAX(v.S_ID)+99´´, MAX(v.S_ID) AS ´´MAX(v.S_ID)´´, MAX(s.S_ID)+99 AS ´´MAX(s.S_ID)+99´´, MAX(s.S_ID) AS ´´MAX(s.S_ID)´´ FROM stadtview AS v, stadt AS s ; INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 10000002 ) ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 e) # Löschen Sie die Stadt aus der Sicht. DELETE FROM stadtview WHERE einwohner = 10000002 ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 f) # Löschen Sie die Stadt aus der Relation Stadt. DELETE FROM stadt WHERE einwohner = 10000002 # Klar, wir wissen ja, das hat auswirkungen auf VIEWs und RELATION ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # Und wieder löschen, für den nächsten Versuch :) DROP VIEW stadtview; DELETE FROM STADT WHERE S_ID > 629;');"
 
 onkeypress="'CREATE VIEW stadtview ( s_id, name, einwohner) AS SELECT s_id, name, einwohner FROM stadt WHERE einwohner > 10000000; # Die Sicht ist erzeugt, jetzt wollen doch mal sehen was so drin steckt. SELECT * FROM stadtview; # 2.3.3.3 a) Stadt in Sicht mit mehr als fünf Millionen Einwohnern einfügen und ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview), \'TestStadt\', 10000001 ); SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id # Interessant ist, das der eben eingefügte Datensatz zweimal angezeigt wird. # Man sieht (vielleicht überraschend) dass der Datensatz in Tabelle stadt eingefügt wurde. # obwohl der insert_ eindeutig in die view einfügt. ; # 2.3.3.3 b) DELETE FROM stadtview WHERE name = \'TestStadt\' # Wir werden gleich sehen, das sich dieses löschen # wieder auf die Tabelle ausgwirkte. Im View ist der Eintrag auch nicht mehr zu finden. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 c) # Fügen Sie eine Stadt mit weniger als fünf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht und die Relation Stadt ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 11 ) # Wir werden sehen, dieser neue Datensatz erstens wieder in Tabelle stadt # eingefügt wurde und zweitens in stadtview nicht mehr auftaucht, ganz gemäß # der Bedinungen des VIEWS bezüglich der Einwohnerzahl. Fein :) # Also alles so wie es sein sollte. Der VIEW bleibt stimmig. ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 d) # Fügen Sie die Stadt erneut mit mehr als fünf Millionen Einwohnern in die Sicht ein. # Lassen Sie sich die Sicht ausgeben. INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+99 FROM stadtview ), \'TestStadt\', 10000002 ) # Interessant hier gibt es eine Fehlermeldung, weil dieser Index für den letzten Einfug in stadt # verwendet wurde, also belegt ist. # Dies wird nicht erkannt bzw. berücksichtig, da letzer Einfug nicht im VIEW vermerkt ist. ; SELECT MAX(v.S_ID)+99 AS ´´MAX(v.S_ID)+99´´, MAX(v.S_ID) AS ´´MAX(v.S_ID)´´, MAX(s.S_ID)+99 AS ´´MAX(s.S_ID)+99´´, MAX(s.S_ID) AS ´´MAX(s.S_ID)´´ FROM stadtview AS v, stadt AS s ; INSERT INTO stadtview (s_id, name, einwohner) VALUES ( ( SELECT MAX(S_ID)+1 FROM stadt ), \'TestStadt\', 10000002 ) ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 e) # Löschen Sie die Stadt aus der Sicht. DELETE FROM stadtview WHERE einwohner = 10000002 ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # 2.3.3.3 f) # Löschen Sie die Stadt aus der Relation Stadt. DELETE FROM stadt WHERE einwohner = 10000002 # Klar, wir wissen ja, das hat auswirkungen auf VIEWs und RELATION ; SELECT s_id, concat(name , \'von stadtview\') , einwohner FROM stadtview WHERE name LIKE \'%TestStadt%\' UNION SELECT s_id, concat(name , \'von stadt\'), einwohner FROM stadt WHERE name LIKE \'%TestStadt%\' ORDER BY s_id ; # Und wieder löschen, für den nächsten Versuch :) DROP VIEW stadtview; DELETE FROM STADT WHERE S_ID > 629;'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em><b><u>2.3.4.1</u></b> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=5.htm"
 onmouseover="show_text_in_form('Bestimmung sämtliche Nachbar-IDs von Bundesrepublik_Deutschland. \nTip: Eine Sicht anzulegen, um nur eine Anfrage zu stellen, ist etwas umständlich.  \nDafür gibt es die WITH-Anweisung.','select%20l.name, b.L_ID1, b.L_ID2 FROM LAND l , BENACHBART b WHERE l.NAME LIKE \'%Deutschland%\' AND ( l.L_ID = b.L_ID2 OR l.L_ID = b.L_ID1 )');"
 >SEL...</a> 
<a href="javascript:show_text_in_form('select%20l.name, b.L_ID1, b.L_ID2 FROM LAND l , BENACHBART b WHERE l.NAME LIKE \'%Deutschland%\' AND ( l.L_ID = b.L_ID2 OR l.L_ID = b.L_ID1 )','select%20l.name, b.L_ID1, b.L_ID2 FROM LAND l , BENACHBART b WHERE l.NAME LIKE \'%Deutschland%\' AND ( l.L_ID = b.L_ID2 OR l.L_ID = b.L_ID1 )');alert('Bestimmung sämtliche Nachbar-IDs von Bundesrepublik_Deutschland. \nTip: Eine Sicht anzulegen, um nur eine Anfrage zu stellen, ist etwas umständlich.  \nDafür gibt es die WITH-Anweisung.');"
 onmouseover="show_text_in_form('Bestimmung sämtliche Nachbar-IDs von Bundesrepublik_Deutschland. \nTip: Eine Sicht anzulegen, um nur eine Anfrage zu stellen, ist etwas umständlich.  \nDafür gibt es die WITH-Anweisung.','select%20l.name, b.L_ID1, b.L_ID2 FROM LAND l , BENACHBART b WHERE l.NAME LIKE \'%Deutschland%\' AND ( l.L_ID = b.L_ID2 OR l.L_ID = b.L_ID1 )');"
 
 onkeypress="'SELECT l.NAME, b.L_ID1, b.L_ID2 FROM LAND l , BENACHBART b WHERE l.NAME LIKE \'%Deutschland%\' AND ( l.L_ID = b.L_ID2 OR l.L_ID = b.L_ID1 )'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em>2.3.4.1 a) Bevölkerungsdichte <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=6.htm"
 onmouseover="show_text_in_form('Bestimmen Sie die Bevölkerungsdichte der Region, die die Länder Algerien, \nLibyen und sämtliche Nachbarn dieser Länder umfaßt. \nTip: Eine Sicht anzulegen, um nur eine Anfrage zu stellen, ist etwas umständlich. \n','SELECT * FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Wir brauchen also die Länder Algerien, Libyen # Bevölkerungsdichte müsste Einwohner pro Fläche sein, also: SELECT name, einwohner/ flaeche AS ´´Bevölkerungsdichte´´ FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # zusammen SELECT avg(einwohner/ flaeche) AS ´´Bevölkerungsdichte´´ FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Ok soweit, jetzt sollten noch alle Nachbarn einbezogen werden. # Da hilft die Tabelle benachbart( l_id1 , l_id2 ) # Suchen wir erst mal alle Länder ids der Nachbarn. SELECT l_id1, l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) OR l_id2 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) # Man muss hier aufpassen das man statt IN nicht versehentlich = schreibt. # Es gäbe hier zwar keinen Fehler aber auch keine Ergebnisse. ; SELECT l_id1 AS ´´l_id1 Nachbarn´´, l_id2 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # So haben wir erst mal alle ids der Nachbarn in der Spalte l_id1 von 6 bzw. 84 # Aber es könnte vielleicht ja Nachbarn in der anderen Spalte auch gebeen. # Schaun wir mal. ; SELECT l_id1 , l_id2 AS ´´l_id2 Nachbarn´´ FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # alle ids der Nachbarn stehen in der Spalte l_id2 von 6 bzw. 84 ; SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Jetzt haben wir tatsächlich alle Nachbarländer, aber es sieh etas unschön aus, finde ich. # Mit dem letzten beiden or kriegen wir unsere beiden Länder auch noch hinnein. # Es sollte auch eleganter gehen. # Schauen wir mal was redundant ist und ersetzten dies mit einer temporären Sicht. ; # Folgender Ansatz, hätte gehen sollen, geht aber nicht :( Warum eigentlich? WITH my_region (l_id) AS ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( my_region ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( my_region ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Dise Vereinfachung führt leider zu Fehler ... ich weiss auch nicht warum. ; WITH my_region (l_id) AS ( SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id2 AND b.l_id1 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') UNION SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id1 AND b.l_id2 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') ) SELECT l.name AS name, l.einwohner AS einwohner, l.flaeche AS flaeche FROM land l, my_region WHERE l.l_id = my_region.l_id # Das hier klappt.');"
 >SEL...</a> 
<a href="javascript:show_text_in_form('SELECT * FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Wir brauchen also die Länder Algerien, Libyen # Bevölkerungsdichte müsste Einwohner pro Fläche sein, also: SELECT name, einwohner/ flaeche AS ´´Bevölkerungsdichte´´ FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # zusammen SELECT avg(einwohner/ flaeche) AS ´´Bevölkerungsdichte´´ FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Ok soweit, jetzt sollten noch alle Nachbarn einbezogen werden. # Da hilft die Tabelle benachbart( l_id1 , l_id2 ) # Suchen wir erst mal alle Länder ids der Nachbarn. SELECT l_id1, l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) OR l_id2 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) # Man muss hier aufpassen das man statt IN nicht versehentlich = schreibt. # Es gäbe hier zwar keinen Fehler aber auch keine Ergebnisse. ; SELECT l_id1 AS ´´l_id1 Nachbarn´´, l_id2 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # So haben wir erst mal alle ids der Nachbarn in der Spalte l_id1 von 6 bzw. 84 # Aber es könnte vielleicht ja Nachbarn in der anderen Spalte auch gebeen. # Schaun wir mal. ; SELECT l_id1 , l_id2 AS ´´l_id2 Nachbarn´´ FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # alle ids der Nachbarn stehen in der Spalte l_id2 von 6 bzw. 84 ; SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Jetzt haben wir tatsächlich alle Nachbarländer, aber es sieh etas unschön aus, finde ich. # Mit dem letzten beiden or kriegen wir unsere beiden Länder auch noch hinnein. # Es sollte auch eleganter gehen. # Schauen wir mal was redundant ist und ersetzten dies mit einer temporären Sicht. ; # Folgender Ansatz, hätte gehen sollen, geht aber nicht :( Warum eigentlich? WITH my_region (l_id) AS ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( my_region ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( my_region ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Dise Vereinfachung führt leider zu Fehler ... ich weiss auch nicht warum. ; WITH my_region (l_id) AS ( SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id2 AND b.l_id1 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') UNION SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id1 AND b.l_id2 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') ) SELECT l.name AS name, l.einwohner AS einwohner, l.flaeche AS flaeche FROM land l, my_region WHERE l.l_id = my_region.l_id # Das hier klappt.','SELECT * FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Wir brauchen also die Länder Algerien, Libyen # Bevölkerungsdichte müsste Einwohner pro Fläche sein, also: SELECT name, einwohner/ flaeche AS ´´Bevölkerungsdichte´´ FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # zusammen SELECT avg(einwohner/ flaeche) AS ´´Bevölkerungsdichte´´ FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Ok soweit, jetzt sollten noch alle Nachbarn einbezogen werden. # Da hilft die Tabelle benachbart( l_id1 , l_id2 ) # Suchen wir erst mal alle Länder ids der Nachbarn. SELECT l_id1, l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) OR l_id2 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) # Man muss hier aufpassen das man statt IN nicht versehentlich = schreibt. # Es gäbe hier zwar keinen Fehler aber auch keine Ergebnisse. ; SELECT l_id1 AS ´´l_id1 Nachbarn´´, l_id2 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # So haben wir erst mal alle ids der Nachbarn in der Spalte l_id1 von 6 bzw. 84 # Aber es könnte vielleicht ja Nachbarn in der anderen Spalte auch gebeen. # Schaun wir mal. ; SELECT l_id1 , l_id2 AS ´´l_id2 Nachbarn´´ FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # alle ids der Nachbarn stehen in der Spalte l_id2 von 6 bzw. 84 ; SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Jetzt haben wir tatsächlich alle Nachbarländer, aber es sieh etas unschön aus, finde ich. # Mit dem letzten beiden or kriegen wir unsere beiden Länder auch noch hinnein. # Es sollte auch eleganter gehen. # Schauen wir mal was redundant ist und ersetzten dies mit einer temporären Sicht. ; # Folgender Ansatz, hätte gehen sollen, geht aber nicht :( Warum eigentlich? WITH my_region (l_id) AS ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( my_region ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( my_region ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Dise Vereinfachung führt leider zu Fehler ... ich weiss auch nicht warum. ; WITH my_region (l_id) AS ( SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id2 AND b.l_id1 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') UNION SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id1 AND b.l_id2 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') ) SELECT l.name AS name, l.einwohner AS einwohner, l.flaeche AS flaeche FROM land l, my_region WHERE l.l_id = my_region.l_id # Das hier klappt.');alert('Bestimmen Sie die Bevölkerungsdichte der Region, die die Länder Algerien, \nLibyen und sämtliche Nachbarn dieser Länder umfaßt. \nTip: Eine Sicht anzulegen, um nur eine Anfrage zu stellen, ist etwas umständlich. \n');"
 onmouseover="show_text_in_form('Bestimmen Sie die Bevölkerungsdichte der Region, die die Länder Algerien, \nLibyen und sämtliche Nachbarn dieser Länder umfaßt. \nTip: Eine Sicht anzulegen, um nur eine Anfrage zu stellen, ist etwas umständlich. \n','SELECT * FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Wir brauchen also die Länder Algerien, Libyen # Bevölkerungsdichte müsste Einwohner pro Fläche sein, also: SELECT name, einwohner/ flaeche AS ´´Bevölkerungsdichte´´ FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # zusammen SELECT avg(einwohner/ flaeche) AS ´´Bevölkerungsdichte´´ FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Ok soweit, jetzt sollten noch alle Nachbarn einbezogen werden. # Da hilft die Tabelle benachbart( l_id1 , l_id2 ) # Suchen wir erst mal alle Länder ids der Nachbarn. SELECT l_id1, l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) OR l_id2 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) # Man muss hier aufpassen das man statt IN nicht versehentlich = schreibt. # Es gäbe hier zwar keinen Fehler aber auch keine Ergebnisse. ; SELECT l_id1 AS ´´l_id1 Nachbarn´´, l_id2 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # So haben wir erst mal alle ids der Nachbarn in der Spalte l_id1 von 6 bzw. 84 # Aber es könnte vielleicht ja Nachbarn in der anderen Spalte auch gebeen. # Schaun wir mal. ; SELECT l_id1 , l_id2 AS ´´l_id2 Nachbarn´´ FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # alle ids der Nachbarn stehen in der Spalte l_id2 von 6 bzw. 84 ; SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Jetzt haben wir tatsächlich alle Nachbarländer, aber es sieh etas unschön aus, finde ich. # Mit dem letzten beiden or kriegen wir unsere beiden Länder auch noch hinnein. # Es sollte auch eleganter gehen. # Schauen wir mal was redundant ist und ersetzten dies mit einer temporären Sicht. ; # Folgender Ansatz, hätte gehen sollen, geht aber nicht :( Warum eigentlich? WITH my_region (l_id) AS ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( my_region ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( my_region ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Dise Vereinfachung führt leider zu Fehler ... ich weiss auch nicht warum. ; WITH my_region (l_id) AS ( SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id2 AND b.l_id1 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') UNION SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id1 AND b.l_id2 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') ) SELECT l.name AS name, l.einwohner AS einwohner, l.flaeche AS flaeche FROM land l, my_region WHERE l.l_id = my_region.l_id # Das hier klappt.');"
 
 onkeypress="'SELECT * FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Wir brauchen also die Länder Algerien, Libyen # Bevölkerungsdichte müsste Einwohner pro Fläche sein, also: SELECT name, einwohner/ flaeche AS ´´Bevölkerungsdichte´´ FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # zusammen SELECT avg(einwohner/ flaeche) AS ´´Bevölkerungsdichte´´ FROM land AS l1 WHERE (name = \'Algerien\' OR name = \'Libyen\') ; # Ok soweit, jetzt sollten noch alle Nachbarn einbezogen werden. # Da hilft die Tabelle benachbart( l_id1 , l_id2 ) # Suchen wir erst mal alle Länder ids der Nachbarn. SELECT l_id1, l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) OR l_id2 IN ( SELECT l_id FROM land AS l1 WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) # Man muss hier aufpassen das man statt IN nicht versehentlich = schreibt. # Es gäbe hier zwar keinen Fehler aber auch keine Ergebnisse. ; SELECT l_id1 AS ´´l_id1 Nachbarn´´, l_id2 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # So haben wir erst mal alle ids der Nachbarn in der Spalte l_id1 von 6 bzw. 84 # Aber es könnte vielleicht ja Nachbarn in der anderen Spalte auch gebeen. # Schaun wir mal. ; SELECT l_id1 , l_id2 AS ´´l_id2 Nachbarn´´ FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE (name LIKE \'Algerien%\' OR name LIKE \'Libyen%\') ) # alle ids der Nachbarn stehen in der Spalte l_id2 von 6 bzw. 84 ; SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Jetzt haben wir tatsächlich alle Nachbarländer, aber es sieh etas unschön aus, finde ich. # Mit dem letzten beiden or kriegen wir unsere beiden Länder auch noch hinnein. # Es sollte auch eleganter gehen. # Schauen wir mal was redundant ist und ersetzten dies mit einer temporären Sicht. ; # Folgender Ansatz, hätte gehen sollen, geht aber nicht :( Warum eigentlich? WITH my_region (l_id) AS ( SELECT l_id FROM land WHERE name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' ) SELECT * FROM land WHERE l_id IN ( SELECT l_id1 FROM benachbart WHERE l_id2 IN ( my_region ) ) OR l_id IN ( SELECT l_id2 FROM benachbart WHERE l_id1 IN ( my_region ) ) OR name LIKE \'Algerien%\' OR name LIKE \'Libyen%\' # Dise Vereinfachung führt leider zu Fehler ... ich weiss auch nicht warum. ; WITH my_region (l_id) AS ( SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id2 AND b.l_id1 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') UNION SELECT l.l_id FROM land l, benachbart b, land l2 WHERE l.l_id = b.l_id1 AND b.l_id2 = l2.l_id AND (l2.name = \'Algerien\' OR l2.name = \'Libyen\') ) SELECT l.name AS name, l.einwohner AS einwohner, l.flaeche AS flaeche FROM land l, my_region WHERE l.l_id = my_region.l_id # Das hier klappt.'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em>2.3.4.1 b) Bevölkerungsdichte ohne Wüsten <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=7.htm"
 onmouseover="show_text_in_form('2.3.4.1 b) Vergleichen Sie das Ergebnis mit der Bevölkerungsdichte die man erhält, wenn \nman die Wüsten als unbewohnbar berücksichtigt. \n','# Wüsten wo sind die? SELECT w.w_id AS ´´w.w_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´ FROM wueste AS w # Aber welche wüsten muss ich berücksichtigen ? ; # Hat das was mit Tabelle geo_wueste zu tun ? SELECT g.lt_id AS ´´g.lt_id´´, g.w_id AS ´´g.w_id´´ FROM geo_wueste AS g ; # Und wohl der Tabelle landesteil SELECT l.lt_id AS ´´lt.lt_id´´, lt.name AS ´´lt.name´´, lt.l_id AS ´´lt.l_id´´, lt.einwohner AS ´´lt.einwohner´´, lt.lage AS ´´lt.lage´´, lt.hauptstadt AS ´´lt.hauptstadt´´ FROM landesteil AS lt # Hier sehen wir einen zusammenhang zwischen lt.lt_id und lt.l_id ; SELECT l.l_id AS ´´l.l_id´´, l.name AS ´´l.name´´, l.einwohner AS ´´l.einwohner´´, l.zuwachs AS ´´l.zuwachs´´, l.flaeche AS ´´l.flaeche´´, l.bsp AS ´´l.bsp´´, l.staatsform AS ´´l.staatsform´´, l.regierungschef AS ´´l.regierungschef´´, l.hauptstadt AS ´´l.hauptstadt´´ FROM land AS l # Hier haben wir dann wieder unsere l.l_id ; # Ich will erst mal ausgeben können wo eine Wüste liegt, in welchem Land bzw. in welchen Ländern. SELECT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id ; Ich verstehe nicht warum es oben mehrere gleiche Ergebnisszeilen gibt, natürlich lassen sich die leicht entfernen: SELECT DISTINCT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id # Außerdem will ich diesen Zusammenhang für alle 30 Wüsten angezeigt haben, jetzt sind es aber plötzlich nur noch 2 ; SELECT DISTINCT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt,%20land%20as%20l%20where%20w.w_id%20=%20g.lt_id%20and%20g.lt_id%20=%20lt.lt_id%20and%20l0caf2b84, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name%29%20order%20by%20w.w_id, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name # Ich glaube wir müssen da mit UNION arbeiten ... nee ... oder wie? ; SELECT DISTINCT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id');"
 ># W...</a> 
<a href="javascript:show_text_in_form('# Wüsten wo sind die? SELECT w.w_id AS ´´w.w_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´ FROM wueste AS w # Aber welche wüsten muss ich berücksichtigen ? ; # Hat das was mit Tabelle geo_wueste zu tun ? SELECT g.lt_id AS ´´g.lt_id´´, g.w_id AS ´´g.w_id´´ FROM geo_wueste AS g ; # Und wohl der Tabelle landesteil SELECT l.lt_id AS ´´lt.lt_id´´, lt.name AS ´´lt.name´´, lt.l_id AS ´´lt.l_id´´, lt.einwohner AS ´´lt.einwohner´´, lt.lage AS ´´lt.lage´´, lt.hauptstadt AS ´´lt.hauptstadt´´ FROM landesteil AS lt # Hier sehen wir einen zusammenhang zwischen lt.lt_id und lt.l_id ; SELECT l.l_id AS ´´l.l_id´´, l.name AS ´´l.name´´, l.einwohner AS ´´l.einwohner´´, l.zuwachs AS ´´l.zuwachs´´, l.flaeche AS ´´l.flaeche´´, l.bsp AS ´´l.bsp´´, l.staatsform AS ´´l.staatsform´´, l.regierungschef AS ´´l.regierungschef´´, l.hauptstadt AS ´´l.hauptstadt´´ FROM land AS l # Hier haben wir dann wieder unsere l.l_id ; # Ich will erst mal ausgeben können wo eine Wüste liegt, in welchem Land bzw. in welchen Ländern. SELECT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id ; Ich verstehe nicht warum es oben mehrere gleiche Ergebnisszeilen gibt, natürlich lassen sich die leicht entfernen: SELECT DISTINCT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id # Außerdem will ich diesen Zusammenhang für alle 30 Wüsten angezeigt haben, jetzt sind es aber plötzlich nur noch 2 ; SELECT DISTINCT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt,%20land%20as%20l%20where%20w.w_id%20=%20g.lt_id%20and%20g.lt_id%20=%20lt.lt_id%20and%20l0caf2b84, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name%29%20order%20by%20w.w_id, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name # Ich glaube wir müssen da mit UNION arbeiten ... nee ... oder wie? ; SELECT DISTINCT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id','# Wüsten wo sind die? SELECT w.w_id AS ´´w.w_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´ FROM wueste AS w # Aber welche wüsten muss ich berücksichtigen ? ; # Hat das was mit Tabelle geo_wueste zu tun ? SELECT g.lt_id AS ´´g.lt_id´´, g.w_id AS ´´g.w_id´´ FROM geo_wueste AS g ; # Und wohl der Tabelle landesteil SELECT l.lt_id AS ´´lt.lt_id´´, lt.name AS ´´lt.name´´, lt.l_id AS ´´lt.l_id´´, lt.einwohner AS ´´lt.einwohner´´, lt.lage AS ´´lt.lage´´, lt.hauptstadt AS ´´lt.hauptstadt´´ FROM landesteil AS lt # Hier sehen wir einen zusammenhang zwischen lt.lt_id und lt.l_id ; SELECT l.l_id AS ´´l.l_id´´, l.name AS ´´l.name´´, l.einwohner AS ´´l.einwohner´´, l.zuwachs AS ´´l.zuwachs´´, l.flaeche AS ´´l.flaeche´´, l.bsp AS ´´l.bsp´´, l.staatsform AS ´´l.staatsform´´, l.regierungschef AS ´´l.regierungschef´´, l.hauptstadt AS ´´l.hauptstadt´´ FROM land AS l # Hier haben wir dann wieder unsere l.l_id ; # Ich will erst mal ausgeben können wo eine Wüste liegt, in welchem Land bzw. in welchen Ländern. SELECT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id ; Ich verstehe nicht warum es oben mehrere gleiche Ergebnisszeilen gibt, natürlich lassen sich die leicht entfernen: SELECT DISTINCT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id # Außerdem will ich diesen Zusammenhang für alle 30 Wüsten angezeigt haben, jetzt sind es aber plötzlich nur noch 2 ; SELECT DISTINCT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt,%20land%20as%20l%20where%20w.w_id%20=%20g.lt_id%20and%20g.lt_id%20=%20lt.lt_id%20and%20l0caf2b84, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name%29%20order%20by%20w.w_id, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name # Ich glaube wir müssen da mit UNION arbeiten ... nee ... oder wie? ; SELECT DISTINCT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id');alert('2.3.4.1 b) Vergleichen Sie das Ergebnis mit der Bevölkerungsdichte die man erhält, wenn \nman die Wüsten als unbewohnbar berücksichtigt. \n');"
 onmouseover="show_text_in_form('2.3.4.1 b) Vergleichen Sie das Ergebnis mit der Bevölkerungsdichte die man erhält, wenn \nman die Wüsten als unbewohnbar berücksichtigt. \n','# Wüsten wo sind die? SELECT w.w_id AS ´´w.w_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´ FROM wueste AS w # Aber welche wüsten muss ich berücksichtigen ? ; # Hat das was mit Tabelle geo_wueste zu tun ? SELECT g.lt_id AS ´´g.lt_id´´, g.w_id AS ´´g.w_id´´ FROM geo_wueste AS g ; # Und wohl der Tabelle landesteil SELECT l.lt_id AS ´´lt.lt_id´´, lt.name AS ´´lt.name´´, lt.l_id AS ´´lt.l_id´´, lt.einwohner AS ´´lt.einwohner´´, lt.lage AS ´´lt.lage´´, lt.hauptstadt AS ´´lt.hauptstadt´´ FROM landesteil AS lt # Hier sehen wir einen zusammenhang zwischen lt.lt_id und lt.l_id ; SELECT l.l_id AS ´´l.l_id´´, l.name AS ´´l.name´´, l.einwohner AS ´´l.einwohner´´, l.zuwachs AS ´´l.zuwachs´´, l.flaeche AS ´´l.flaeche´´, l.bsp AS ´´l.bsp´´, l.staatsform AS ´´l.staatsform´´, l.regierungschef AS ´´l.regierungschef´´, l.hauptstadt AS ´´l.hauptstadt´´ FROM land AS l # Hier haben wir dann wieder unsere l.l_id ; # Ich will erst mal ausgeben können wo eine Wüste liegt, in welchem Land bzw. in welchen Ländern. SELECT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id ; Ich verstehe nicht warum es oben mehrere gleiche Ergebnisszeilen gibt, natürlich lassen sich die leicht entfernen: SELECT DISTINCT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id # Außerdem will ich diesen Zusammenhang für alle 30 Wüsten angezeigt haben, jetzt sind es aber plötzlich nur noch 2 ; SELECT DISTINCT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt,%20land%20as%20l%20where%20w.w_id%20=%20g.lt_id%20and%20g.lt_id%20=%20lt.lt_id%20and%20l0caf2b84, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name%29%20order%20by%20w.w_id, g.lt_id, lt.lt_id,%20l.l_id,w.name,w.flaeche,w.wuestenart,l.name # Ich glaube wir müssen da mit UNION arbeiten ... nee ... oder wie? ; SELECT DISTINCT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id');"
 
 onkeypress="'# Wüsten wo sind die? SELECT w.w_id AS ´´w.w_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´ FROM wueste AS w # Aber welche wüsten muss ich berücksichtigen ? ; # Hat das was mit Tabelle geo_wueste zu tun ? SELECT g.lt_id AS ´´g.lt_id´´, g.w_id AS ´´g.w_id´´ FROM geo_wueste AS g ; # Und wohl der Tabelle landesteil SELECT l.lt_id AS ´´lt.lt_id´´, lt.name AS ´´lt.name´´, lt.l_id AS ´´lt.l_id´´, lt.einwohner AS ´´lt.einwohner´´, lt.lage AS ´´lt.lage´´, lt.hauptstadt AS ´´lt.hauptstadt´´ FROM landesteil AS lt # Hier sehen wir einen zusammenhang zwischen lt.lt_id und lt.l_id ; SELECT l.l_id AS ´´l.l_id´´, l.name AS ´´l.name´´, l.einwohner AS ´´l.einwohner´´, l.zuwachs AS ´´l.zuwachs´´, l.flaeche AS ´´l.flaeche´´, l.bsp AS ´´l.bsp´´, l.staatsform AS ´´l.staatsform´´, l.regierungschef AS ´´l.regierungschef´´, l.hauptstadt AS ´´l.hauptstadt´´ FROM land AS l # Hier haben wir dann wieder unsere l.l_id ; # Ich will erst mal ausgeben können wo eine Wüste liegt, in welchem Land bzw. in welchen Ländern. SELECT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id ; Ich verstehe nicht warum es oben mehrere gleiche Ergebnisszeilen gibt, natürlich lassen sich die leicht entfernen: SELECT DISTINCT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id # Außerdem will ich diesen Zusammenhang für alle 30 Wüsten angezeigt haben, jetzt sind es aber plötzlich nur noch 2 ; SELECT DISTINCT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id AND g.lt_id = lt.lt_id AND lt.l_id = l.l_id GROUP BY ROLLUP(w.w_id, g.lt_id, lt.lt_id, l.l_id,w.name,w.flaeche,w.wuestenart,l.name) ORDER BY w.w_id, g.lt_id, lt.lt_id, l.l_id,w.name,w.flaeche,w.wuestenart,l.name # Ich glaube wir müssen da mit UNION arbeiten ... nee ... oder wie? ; SELECT DISTINCT w.w_id AS ´´w.w_id´´, g.lt_id AS ´´g.lt_id´´ , lt.lt_id AS ´´lt.lt_id´´, l.l_id AS ´´l.l_id´´, w.name AS ´´w.name´´, w.flaeche AS ´´w.flaeche´´, w.wuestenart AS ´´w.wuestenart´´, l.name AS ´´l.name´´ FROM geo_wueste AS g, wueste AS w, landesteil AS lt, land AS l WHERE w.w_id = g.lt_id'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em><b><u>4.4.5</u></b> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=8.htm"
 onmouseover="show_text_in_form('Eine kleine Applikation \n1.  Implementieren Sie eine Webanfrageschnittstelle für DB2 (ähnlich der Schnittstelle \n die für die Vorlesung DBS I eingesetzt wird). \n2.  Falls noch nicht geschehen, erweitern Sie die Schnittstelle so, da. auch Insert-, \n Update- und Delete-Ausdrücke verarbeitet werden können. Geben Sie dabei als \n Ausgabe die Anzahl der veränderten bzw. eingefügten/gelöschten Tupel an.','SELECT * FROM BERG');"
 >SEL...</a> 
<a href="javascript:show_text_in_form('SELECT * FROM BERG','SELECT * FROM BERG');alert('Eine kleine Applikation \n1.  Implementieren Sie eine Webanfrageschnittstelle für DB2 (ähnlich der Schnittstelle \n die für die Vorlesung DBS I eingesetzt wird). \n2.  Falls noch nicht geschehen, erweitern Sie die Schnittstelle so, da. auch Insert-, \n Update- und Delete-Ausdrücke verarbeitet werden können. Geben Sie dabei als \n Ausgabe die Anzahl der veränderten bzw. eingefügten/gelöschten Tupel an.');"
 onmouseover="show_text_in_form('Eine kleine Applikation \n1.  Implementieren Sie eine Webanfrageschnittstelle für DB2 (ähnlich der Schnittstelle \n die für die Vorlesung DBS I eingesetzt wird). \n2.  Falls noch nicht geschehen, erweitern Sie die Schnittstelle so, da. auch Insert-, \n Update- und Delete-Ausdrücke verarbeitet werden können. Geben Sie dabei als \n Ausgabe die Anzahl der veränderten bzw. eingefügten/gelöschten Tupel an.','SELECT * FROM BERG');"
 
 onkeypress="'SELECT * FROM BERG'">Text</a></font><font size="+1"> <b><br>&#664</b> <b><u>GROUP und DISTINCT</u></b> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=9.htm"
 onmouseover="show_text_in_form('Und einmal ohne DISTINCT SELECT ...','SELECT * FROM berg WHERE gebirge < \'b\' ORDER BY gebirge ASC ; # DISTINCT entfernt doppelt Werte SELECT DISTINCT gebirge FROM berg WHERE gebirge < \'b\' ; # Obwohl hier die Ausgabe gleich wie die oben ist, gruppiert GROUP, # und ist damit nicht gleich DISTINCT\' , SELECT gebirge FROM berg GROUP BY gebirge ; SELECT GEBIRGE , COUNT(name) AS ´´AnzahlBerge´´, MAX(HOEHE ) ´´Groester´´ ,MIN(HOEHE ) ´´Kleinster´´, MAX(HOEHE )-MIN(HOEHE ) AS ´´Unterschied´´ FROM BERG GROUP BY GEBIRGE ORDER BY COUNT(name) DESC ; # Hier sieht man zusätzlich eine Zeile die alle Gruppen zusammengefasst, als eine Gruppe behandelt. SELECT GEBIRGE , COUNT(name) AS ´´AnzahlBerge´´, MAX(HOEHE ) ´´Groester´´ ,MIN(HOEHE ) ´´Kleinster´´, MAX(HOEHE )-MIN(HOEHE ) AS ´´Unterschied´´ FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # ROLLUP GROUPING # Jetzt keine Verwechslunksgefahr mehr durch bessere Benennung. (Vgl. Null-Werte) SELECT GROUPING(GEBIRGE) AS ´´GROUPING(gebirge)´´ , CASE GROUPING(gebirge) WHEN 1 THEN \'(-alle Gebirge-)\' ELSE gebirge END AS ´´CASE´´ , GEBIRGE , COUNT(name) AS ´´AnzahlBerge´´, MAX(HOEHE ) ´´Groester´´ ,MIN(HOEHE ) ´´Kleinster´´, MAX(HOEHE )-MIN(HOEHE ) AS ´´Unterschied´´ FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # DISTINCT mehrspaltik</u></b> # DISTINCT sorgt hier nur für einmalige Ergebniszeilen. Doppeltes wird gestrichen. # Vgl. einmal den SELECT nur über die Spalte GEBIRGE SELECT gebirge, name FROM BERG ORDER BY gebirge');"
 >SEL...</a> 
<a href="javascript:show_text_in_form('SELECT * FROM berg WHERE gebirge < \'b\' ORDER BY gebirge ASC ; # DISTINCT entfernt doppelt Werte SELECT DISTINCT gebirge FROM berg WHERE gebirge < \'b\' ; # Obwohl hier die Ausgabe gleich wie die oben ist, gruppiert GROUP, # und ist damit nicht gleich DISTINCT\' , SELECT gebirge FROM berg GROUP BY gebirge ; SELECT GEBIRGE , COUNT(name) AS ´´AnzahlBerge´´, MAX(HOEHE ) ´´Groester´´ ,MIN(HOEHE ) ´´Kleinster´´, MAX(HOEHE )-MIN(HOEHE ) AS ´´Unterschied´´ FROM BERG GROUP BY GEBIRGE ORDER BY COUNT(name) DESC ; # Hier sieht man zusätzlich eine Zeile die alle Gruppen zusammengefasst, als eine Gruppe behandelt. SELECT GEBIRGE , COUNT(name) AS ´´AnzahlBerge´´, MAX(HOEHE ) ´´Groester´´ ,MIN(HOEHE ) ´´Kleinster´´, MAX(HOEHE )-MIN(HOEHE ) AS ´´Unterschied´´ FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # ROLLUP GROUPING # Jetzt keine Verwechslunksgefahr mehr durch bessere Benennung. (Vgl. Null-Werte) SELECT GROUPING(GEBIRGE) AS ´´GROUPING(gebirge)´´ , CASE GROUPING(gebirge) WHEN 1 THEN \'(-alle Gebirge-)\' ELSE gebirge END AS ´´CASE´´ , GEBIRGE , COUNT(name) AS ´´AnzahlBerge´´, MAX(HOEHE ) ´´Groester´´ ,MIN(HOEHE ) ´´Kleinster´´, MAX(HOEHE )-MIN(HOEHE ) AS ´´Unterschied´´ FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # DISTINCT mehrspaltik</u></b> # DISTINCT sorgt hier nur für einmalige Ergebniszeilen. Doppeltes wird gestrichen. # Vgl. einmal den SELECT nur über die Spalte GEBIRGE SELECT gebirge, name FROM BERG ORDER BY gebirge','SELECT * FROM berg WHERE gebirge < \'b\' ORDER BY gebirge ASC ; # DISTINCT entfernt doppelt Werte SELECT DISTINCT gebirge FROM berg WHERE gebirge < \'b\' ; # Obwohl hier die Ausgabe gleich wie die oben ist, gruppiert GROUP, # und ist damit nicht gleich DISTINCT\' , SELECT gebirge FROM berg GROUP BY gebirge ; SELECT GEBIRGE , COUNT(name) AS ´´AnzahlBerge´´, MAX(HOEHE ) ´´Groester´´ ,MIN(HOEHE ) ´´Kleinster´´, MAX(HOEHE )-MIN(HOEHE ) AS ´´Unterschied´´ FROM BERG GROUP BY GEBIRGE ORDER BY COUNT(name) DESC ; # Hier sieht man zusätzlich eine Zeile die alle Gruppen zusammengefasst, als eine Gruppe behandelt. SELECT GEBIRGE , COUNT(name) AS ´´AnzahlBerge´´, MAX(HOEHE ) ´´Groester´´ ,MIN(HOEHE ) ´´Kleinster´´, MAX(HOEHE )-MIN(HOEHE ) AS ´´Unterschied´´ FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # ROLLUP GROUPING # Jetzt keine Verwechslunksgefahr mehr durch bessere Benennung. (Vgl. Null-Werte) SELECT GROUPING(GEBIRGE) AS ´´GROUPING(gebirge)´´ , CASE GROUPING(gebirge) WHEN 1 THEN \'(-alle Gebirge-)\' ELSE gebirge END AS ´´CASE´´ , GEBIRGE , COUNT(name) AS ´´AnzahlBerge´´, MAX(HOEHE ) ´´Groester´´ ,MIN(HOEHE ) ´´Kleinster´´, MAX(HOEHE )-MIN(HOEHE ) AS ´´Unterschied´´ FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # DISTINCT mehrspaltik</u></b> # DISTINCT sorgt hier nur für einmalige Ergebniszeilen. Doppeltes wird gestrichen. # Vgl. einmal den SELECT nur über die Spalte GEBIRGE SELECT gebirge, name FROM BERG ORDER BY gebirge');alert('Und einmal ohne DISTINCT SELECT ...');"
 onmouseover="show_text_in_form('Und einmal ohne DISTINCT SELECT ...','SELECT * FROM berg WHERE gebirge < \'b\' ORDER BY gebirge ASC ; # DISTINCT entfernt doppelt Werte SELECT DISTINCT gebirge FROM berg WHERE gebirge < \'b\' ; # Obwohl hier die Ausgabe gleich wie die oben ist, gruppiert GROUP, # und ist damit nicht gleich DISTINCT\' , SELECT gebirge FROM berg GROUP BY gebirge ; SELECT GEBIRGE , COUNT(name) AS ´´AnzahlBerge´´, MAX(HOEHE ) ´´Groester´´ ,MIN(HOEHE ) ´´Kleinster´´, MAX(HOEHE )-MIN(HOEHE ) AS ´´Unterschied´´ FROM BERG GROUP BY GEBIRGE ORDER BY COUNT(name) DESC ; # Hier sieht man zusätzlich eine Zeile die alle Gruppen zusammengefasst, als eine Gruppe behandelt. SELECT GEBIRGE , COUNT(name) AS ´´AnzahlBerge´´, MAX(HOEHE ) ´´Groester´´ ,MIN(HOEHE ) ´´Kleinster´´, MAX(HOEHE )-MIN(HOEHE ) AS ´´Unterschied´´ FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # ROLLUP GROUPING # Jetzt keine Verwechslunksgefahr mehr durch bessere Benennung. (Vgl. Null-Werte) SELECT GROUPING(GEBIRGE) AS ´´GROUPING(gebirge)´´ , CASE GROUPING(gebirge) WHEN 1 THEN \'(-alle Gebirge-)\' ELSE gebirge END AS ´´CASE´´ , GEBIRGE , COUNT(name) AS ´´AnzahlBerge´´, MAX(HOEHE ) ´´Groester´´ ,MIN(HOEHE ) ´´Kleinster´´, MAX(HOEHE )-MIN(HOEHE ) AS ´´Unterschied´´ FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # DISTINCT mehrspaltik</u></b> # DISTINCT sorgt hier nur für einmalige Ergebniszeilen. Doppeltes wird gestrichen. # Vgl. einmal den SELECT nur über die Spalte GEBIRGE SELECT gebirge, name FROM BERG ORDER BY gebirge');"
 
 onkeypress="'SELECT * FROM berg WHERE gebirge < \'b\' ORDER BY gebirge ASC ; # DISTINCT entfernt doppelt Werte SELECT DISTINCT gebirge FROM berg WHERE gebirge < \'b\' ; # Obwohl hier die Ausgabe gleich wie die oben ist, gruppiert GROUP, # und ist damit nicht gleich DISTINCT\' , SELECT gebirge FROM berg GROUP BY gebirge ; SELECT GEBIRGE , COUNT(name) AS ´´AnzahlBerge´´, MAX(HOEHE ) ´´Groester´´ ,MIN(HOEHE ) ´´Kleinster´´, MAX(HOEHE )-MIN(HOEHE ) AS ´´Unterschied´´ FROM BERG GROUP BY GEBIRGE ORDER BY COUNT(name) DESC ; # Hier sieht man zusätzlich eine Zeile die alle Gruppen zusammengefasst, als eine Gruppe behandelt. SELECT GEBIRGE , COUNT(name) AS ´´AnzahlBerge´´, MAX(HOEHE ) ´´Groester´´ ,MIN(HOEHE ) ´´Kleinster´´, MAX(HOEHE )-MIN(HOEHE ) AS ´´Unterschied´´ FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # ROLLUP GROUPING # Jetzt keine Verwechslunksgefahr mehr durch bessere Benennung. (Vgl. Null-Werte) SELECT GROUPING(GEBIRGE) AS ´´GROUPING(gebirge)´´ , CASE GROUPING(gebirge) WHEN 1 THEN \'(-alle Gebirge-)\' ELSE gebirge END AS ´´CASE´´ , GEBIRGE , COUNT(name) AS ´´AnzahlBerge´´, MAX(HOEHE ) ´´Groester´´ ,MIN(HOEHE ) ´´Kleinster´´, MAX(HOEHE )-MIN(HOEHE ) AS ´´Unterschied´´ FROM BERG GROUP BY ROLLUP(gebirge) ORDER BY COUNT(name) DESC ; # DISTINCT mehrspaltik</u></b> # DISTINCT sorgt hier nur für einmalige Ergebniszeilen. Doppeltes wird gestrichen. # Vgl. einmal den SELECT nur über die Spalte GEBIRGE SELECT gebirge, name FROM BERG ORDER BY gebirge'">Text</a></font><font size="+1"> <b><br>&#664</b> <b><u>UNION(Vereinigung) INTERSECT(Schnittmenge) und EXCEPT(Minus)</u></b> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=10.htm"
 onmouseover="show_text_in_form('T1 UNION T2 \nVereinigung ohne doppelte Ergebnisse. \nErscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal.','# T1 UNION T2 # Vereinigung ohne doppelte Ergebnisse. # Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 UNION ALL T2 # Vereinigung. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie sogar 5-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT T2 # Schnittmenge ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT ALL T2 # Schnittmenge mit bei der kleinere Häufigkeit (wie bei UNION ALL) erhalten bleibt. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T2 EXCEPT T1 # Ergebnisse sind in T2, aber nicht in T1. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' ; # T1 EXCEPT T2 # Ergebnisse sind in T1, aber nicht in T2. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 EXCEPT ALL T2 # Differenz. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie genau 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC');"
 ># T...</a> 
<a href="javascript:show_text_in_form('# T1 UNION T2 # Vereinigung ohne doppelte Ergebnisse. # Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 UNION ALL T2 # Vereinigung. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie sogar 5-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT T2 # Schnittmenge ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT ALL T2 # Schnittmenge mit bei der kleinere Häufigkeit (wie bei UNION ALL) erhalten bleibt. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T2 EXCEPT T1 # Ergebnisse sind in T2, aber nicht in T1. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' ; # T1 EXCEPT T2 # Ergebnisse sind in T1, aber nicht in T2. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 EXCEPT ALL T2 # Differenz. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie genau 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC','# T1 UNION T2 # Vereinigung ohne doppelte Ergebnisse. # Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 UNION ALL T2 # Vereinigung. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie sogar 5-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT T2 # Schnittmenge ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT ALL T2 # Schnittmenge mit bei der kleinere Häufigkeit (wie bei UNION ALL) erhalten bleibt. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T2 EXCEPT T1 # Ergebnisse sind in T2, aber nicht in T1. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' ; # T1 EXCEPT T2 # Ergebnisse sind in T1, aber nicht in T2. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 EXCEPT ALL T2 # Differenz. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie genau 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC');alert('T1 UNION T2 \nVereinigung ohne doppelte Ergebnisse. \nErscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal.');"
 onmouseover="show_text_in_form('T1 UNION T2 \nVereinigung ohne doppelte Ergebnisse. \nErscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal.','# T1 UNION T2 # Vereinigung ohne doppelte Ergebnisse. # Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 UNION ALL T2 # Vereinigung. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie sogar 5-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT T2 # Schnittmenge ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT ALL T2 # Schnittmenge mit bei der kleinere Häufigkeit (wie bei UNION ALL) erhalten bleibt. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T2 EXCEPT T1 # Ergebnisse sind in T2, aber nicht in T1. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' ; # T1 EXCEPT T2 # Ergebnisse sind in T1, aber nicht in T2. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 EXCEPT ALL T2 # Differenz. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie genau 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC');"
 
 onkeypress="'# T1 UNION T2 # Vereinigung ohne doppelte Ergebnisse. # Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie nur 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 UNION ALL T2 # Vereinigung. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie sogar 5-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' UNION ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT T2 # Schnittmenge ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 INTERSECT ALL T2 # Schnittmenge mit bei der kleinere Häufigkeit (wie bei UNION ALL) erhalten bleibt. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' INTERSECT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T2 EXCEPT T1 # Ergebnisse sind in T2, aber nicht in T1. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' ; # T1 EXCEPT T2 # Ergebnisse sind in T1, aber nicht in T2. Ohne doppelte Zeilen. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC ; # T1 EXCEPT ALL T2 # Differenz. Erscheint z.B. Zeile A 3-mal in T1 und 2-mal in T2, erscheint sie genau 1-mal. SELECT gebirge FROM berg WHERE gebirge BETWEEN \'r\' AND \'t\' EXCEPT ALL SELECT gebirge FROM berg WHERE gebirge BETWEEN \'s\' AND \'u\' ORDER BY gebirge ASC'">Text</a></font><font size="+1"> <b><br>&#664</b> <b><u>LEFT|RIGHT|FULL OUTER JOIN</u></b> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=11.htm"
 onmouseover="show_text_in_form('Der "normale" JOIN wird implizit im folgenden verwendet.','SELECT b.hoehe AS ´´b.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e, berg AS b WHERE CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # JOIN # Hier wurde JOIN explizit verwendet. Das Ergebnis ist das selbe. SELECT b.hoehe AS ´´b.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # LEFT OUTER JOIN # Zusätzlich nun auch Zeilen linken Tabelle, welche die WHERE - Bedingung nicht erfüllen. SELECT l.hoehe AS ´´left.hoehe´´ , b.hoehe AS ´´b.hoehe´´ FROM ebene AS l LEFT OUTER JOIN berg AS b ON CAST(l.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY l.hoehe ASC ; # RIGHT OUTER JOIN # Zusätzlich nun auch Zeilen rechten Tabelle, # welche die WHERE - Bedingung nicht erfüllen. SELECT right.hoehe AS ´´right.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e RIGHT OUTER JOIN berg AS right ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(right.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC ; # FULL OUTER JOIN # Zusätzlich nun auch Zeilen beider Tabellen, welche die WHERE - Bedingung nicht erfüllen. SELECT b.hoehe AS ´´b.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e FULL OUTER JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC');"
 >SEL...</a> 
<a href="javascript:show_text_in_form('SELECT b.hoehe AS ´´b.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e, berg AS b WHERE CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # JOIN # Hier wurde JOIN explizit verwendet. Das Ergebnis ist das selbe. SELECT b.hoehe AS ´´b.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # LEFT OUTER JOIN # Zusätzlich nun auch Zeilen linken Tabelle, welche die WHERE - Bedingung nicht erfüllen. SELECT l.hoehe AS ´´left.hoehe´´ , b.hoehe AS ´´b.hoehe´´ FROM ebene AS l LEFT OUTER JOIN berg AS b ON CAST(l.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY l.hoehe ASC ; # RIGHT OUTER JOIN # Zusätzlich nun auch Zeilen rechten Tabelle, # welche die WHERE - Bedingung nicht erfüllen. SELECT right.hoehe AS ´´right.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e RIGHT OUTER JOIN berg AS right ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(right.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC ; # FULL OUTER JOIN # Zusätzlich nun auch Zeilen beider Tabellen, welche die WHERE - Bedingung nicht erfüllen. SELECT b.hoehe AS ´´b.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e FULL OUTER JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC','SELECT b.hoehe AS ´´b.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e, berg AS b WHERE CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # JOIN # Hier wurde JOIN explizit verwendet. Das Ergebnis ist das selbe. SELECT b.hoehe AS ´´b.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # LEFT OUTER JOIN # Zusätzlich nun auch Zeilen linken Tabelle, welche die WHERE - Bedingung nicht erfüllen. SELECT l.hoehe AS ´´left.hoehe´´ , b.hoehe AS ´´b.hoehe´´ FROM ebene AS l LEFT OUTER JOIN berg AS b ON CAST(l.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY l.hoehe ASC ; # RIGHT OUTER JOIN # Zusätzlich nun auch Zeilen rechten Tabelle, # welche die WHERE - Bedingung nicht erfüllen. SELECT right.hoehe AS ´´right.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e RIGHT OUTER JOIN berg AS right ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(right.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC ; # FULL OUTER JOIN # Zusätzlich nun auch Zeilen beider Tabellen, welche die WHERE - Bedingung nicht erfüllen. SELECT b.hoehe AS ´´b.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e FULL OUTER JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC');alert('Der "normale" JOIN wird implizit im folgenden verwendet.');"
 onmouseover="show_text_in_form('Der "normale" JOIN wird implizit im folgenden verwendet.','SELECT b.hoehe AS ´´b.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e, berg AS b WHERE CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # JOIN # Hier wurde JOIN explizit verwendet. Das Ergebnis ist das selbe. SELECT b.hoehe AS ´´b.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # LEFT OUTER JOIN # Zusätzlich nun auch Zeilen linken Tabelle, welche die WHERE - Bedingung nicht erfüllen. SELECT l.hoehe AS ´´left.hoehe´´ , b.hoehe AS ´´b.hoehe´´ FROM ebene AS l LEFT OUTER JOIN berg AS b ON CAST(l.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY l.hoehe ASC ; # RIGHT OUTER JOIN # Zusätzlich nun auch Zeilen rechten Tabelle, # welche die WHERE - Bedingung nicht erfüllen. SELECT right.hoehe AS ´´right.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e RIGHT OUTER JOIN berg AS right ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(right.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC ; # FULL OUTER JOIN # Zusätzlich nun auch Zeilen beider Tabellen, welche die WHERE - Bedingung nicht erfüllen. SELECT b.hoehe AS ´´b.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e FULL OUTER JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC');"
 
 onkeypress="'SELECT b.hoehe AS ´´b.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e, berg AS b WHERE CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # JOIN # Hier wurde JOIN explizit verwendet. Das Ergebnis ist das selbe. SELECT b.hoehe AS ´´b.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ; # LEFT OUTER JOIN # Zusätzlich nun auch Zeilen linken Tabelle, welche die WHERE - Bedingung nicht erfüllen. SELECT l.hoehe AS ´´left.hoehe´´ , b.hoehe AS ´´b.hoehe´´ FROM ebene AS l LEFT OUTER JOIN berg AS b ON CAST(l.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY l.hoehe ASC ; # RIGHT OUTER JOIN # Zusätzlich nun auch Zeilen rechten Tabelle, # welche die WHERE - Bedingung nicht erfüllen. SELECT right.hoehe AS ´´right.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e RIGHT OUTER JOIN berg AS right ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(right.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC ; # FULL OUTER JOIN # Zusätzlich nun auch Zeilen beider Tabellen, welche die WHERE - Bedingung nicht erfüllen. SELECT b.hoehe AS ´´b.hoehe´´, e.hoehe AS ´´e.hoehe´´ FROM ebene AS e FULL OUTER JOIN berg AS b ON CAST(e.hoehe/500 AS DECIMAL(9)) = CAST(b.hoehe/500 AS DECIMAL(9)) ORDER BY e.hoehe ASC'">Text</a></font><font size="+1"> <b>&#664</b> <u>Zufallszahlen - CREATE INSERT <b>WITH</b></u> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=12.htm"
 onmouseover="show_text_in_form('Tabelle mit Zufallszahlen erstellen.','CREATE TABLE zahlen(zähler Integer, zufall Integer) # Tabelle ist erstellt ; INSERT INTO zahlen(zähler, zufall) WITH temporäre_Sicht(n) AS ( VALUES(1) UNION ALL SELECT n+1 FROM temporäre_Sicht WHERE n<2 ) SELECT n, integer(rand()*10) FROM temporäre_Sicht # Das hier ist der interessante Teil gewesen. ; SELECT * FROM zahlen; # Man sieht es hat geklappt. DROP TABLE zahlen;');"
 >CRE...</a> 
<a href="javascript:show_text_in_form('CREATE TABLE zahlen(zähler Integer, zufall Integer) # Tabelle ist erstellt ; INSERT INTO zahlen(zähler, zufall) WITH temporäre_Sicht(n) AS ( VALUES(1) UNION ALL SELECT n+1 FROM temporäre_Sicht WHERE n<2 ) SELECT n, integer(rand()*10) FROM temporäre_Sicht # Das hier ist der interessante Teil gewesen. ; SELECT * FROM zahlen; # Man sieht es hat geklappt. DROP TABLE zahlen;','CREATE TABLE zahlen(zähler Integer, zufall Integer) # Tabelle ist erstellt ; INSERT INTO zahlen(zähler, zufall) WITH temporäre_Sicht(n) AS ( VALUES(1) UNION ALL SELECT n+1 FROM temporäre_Sicht WHERE n<2 ) SELECT n, integer(rand()*10) FROM temporäre_Sicht # Das hier ist der interessante Teil gewesen. ; SELECT * FROM zahlen; # Man sieht es hat geklappt. DROP TABLE zahlen;');alert('Tabelle mit Zufallszahlen erstellen.');"
 onmouseover="show_text_in_form('Tabelle mit Zufallszahlen erstellen.','CREATE TABLE zahlen(zähler Integer, zufall Integer) # Tabelle ist erstellt ; INSERT INTO zahlen(zähler, zufall) WITH temporäre_Sicht(n) AS ( VALUES(1) UNION ALL SELECT n+1 FROM temporäre_Sicht WHERE n<2 ) SELECT n, integer(rand()*10) FROM temporäre_Sicht # Das hier ist der interessante Teil gewesen. ; SELECT * FROM zahlen; # Man sieht es hat geklappt. DROP TABLE zahlen;');"
 
 onkeypress="'CREATE TABLE zahlen(zähler Integer, zufall Integer) # Tabelle ist erstellt ; INSERT INTO zahlen(zähler, zufall) WITH temporäre_Sicht(n) AS ( VALUES(1) UNION ALL SELECT n+1 FROM temporäre_Sicht WHERE n<2 ) SELECT n, integer(rand()*10) FROM temporäre_Sicht # Das hier ist der interessante Teil gewesen. ; SELECT * FROM zahlen; # Man sieht es hat geklappt. DROP TABLE zahlen;'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em><u>2.3.4.2 <b>WITH</b></u> <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=13.htm"
 onmouseover="show_text_in_form('2.3.4.2 \nGeben Sie alle Paare von Ländern mit Meeresküste in Europa aus, die an die gleiche Menge von Meeren angrenzen. \nBeispiel: \n[Belgien, Niederlande] \nda M_Belgien = M_Niederlande = {Nordsee} \n[Belgien, Spanien] sollte nicht auftauchen, \nda M_Spanien = {Atlantik, Mittelmeer} \n','# Alle Länder-Paare innerhalb Europa: WITH europa (l_id, l_name) AS ( SELECT l.l_id AS ´´l.l_id´´, l.name AS ´´l.name´´ FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ) SELECT l1.name ´´l1.name´´, l2.name ´´l2.name´´ FROM benachbart b, land l1, land l2 WHERE b.l_id1 = l1.l_id AND b.l_id2 = l2.l_id AND b.l_id1 IN (SELECT l_id FROM europa) AND b.l_id2 IN (SELECT l_id FROM europa) # ...57 Paare ; # Zuordnung Land und Meer: WITH land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l.name ´´l.name´´, m.name ´´m.name´´ FROM land_meer m, land l WHERE m.l_id = l.l_id ; # Eine mögliche Lösung: WITH europa (l_id,%20l_name%29%20as%20%28%20select%20l.l_id, l.name FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ), europa_paare (l_id1, l_id2) AS ( SELECT l_id1, l_id2 FROM benachbart b WHERE b.l_id1 IN ( SELECT l_id FROM europa )AND b.l_id2 IN ( SELECT l_id FROM europa ) ), land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l1.l_id ´´l1.l_id´´, l1.name ´´l1.name´´, l2.l_id ´´l2.l_id´´, l2.name ´´l2.name´´ FROM land l1, land l2, europa_paare e WHERE l1.l_id = e.l_id1 AND l2.l_id = e.l_id2 AND NOT EXISTS ( SELECT m1.name FROM land_meer m1 WHERE m1.l_id = e.l_id1 EXCEPT ALL SELECT m2.name FROM land_meer m2 WHERE m2.l_id = e.l_id2 ) AND NOT EXISTS ( SELECT m3.name FROM land_meer m3 WHERE m3.l_id = e.l_id2 EXCEPT ALL SELECT m4.name FROM land_meer m4 WHERE m4.l_id = e.l_id1 ) AND EXISTS ( SELECT m5.name FROM land_meer m5 WHERE m5.l_id = e.l_id1 )');"
 ># A...</a> 
<a href="javascript:show_text_in_form('# Alle Länder-Paare innerhalb Europa: WITH europa (l_id, l_name) AS ( SELECT l.l_id AS ´´l.l_id´´, l.name AS ´´l.name´´ FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ) SELECT l1.name ´´l1.name´´, l2.name ´´l2.name´´ FROM benachbart b, land l1, land l2 WHERE b.l_id1 = l1.l_id AND b.l_id2 = l2.l_id AND b.l_id1 IN (SELECT l_id FROM europa) AND b.l_id2 IN (SELECT l_id FROM europa) # ...57 Paare ; # Zuordnung Land und Meer: WITH land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l.name ´´l.name´´, m.name ´´m.name´´ FROM land_meer m, land l WHERE m.l_id = l.l_id ; # Eine mögliche Lösung: WITH europa (l_id,%20l_name%29%20as%20%28%20select%20l.l_id, l.name FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ), europa_paare (l_id1, l_id2) AS ( SELECT l_id1, l_id2 FROM benachbart b WHERE b.l_id1 IN ( SELECT l_id FROM europa )AND b.l_id2 IN ( SELECT l_id FROM europa ) ), land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l1.l_id ´´l1.l_id´´, l1.name ´´l1.name´´, l2.l_id ´´l2.l_id´´, l2.name ´´l2.name´´ FROM land l1, land l2, europa_paare e WHERE l1.l_id = e.l_id1 AND l2.l_id = e.l_id2 AND NOT EXISTS ( SELECT m1.name FROM land_meer m1 WHERE m1.l_id = e.l_id1 EXCEPT ALL SELECT m2.name FROM land_meer m2 WHERE m2.l_id = e.l_id2 ) AND NOT EXISTS ( SELECT m3.name FROM land_meer m3 WHERE m3.l_id = e.l_id2 EXCEPT ALL SELECT m4.name FROM land_meer m4 WHERE m4.l_id = e.l_id1 ) AND EXISTS ( SELECT m5.name FROM land_meer m5 WHERE m5.l_id = e.l_id1 )','# Alle Länder-Paare innerhalb Europa: WITH europa (l_id, l_name) AS ( SELECT l.l_id AS ´´l.l_id´´, l.name AS ´´l.name´´ FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ) SELECT l1.name ´´l1.name´´, l2.name ´´l2.name´´ FROM benachbart b, land l1, land l2 WHERE b.l_id1 = l1.l_id AND b.l_id2 = l2.l_id AND b.l_id1 IN (SELECT l_id FROM europa) AND b.l_id2 IN (SELECT l_id FROM europa) # ...57 Paare ; # Zuordnung Land und Meer: WITH land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l.name ´´l.name´´, m.name ´´m.name´´ FROM land_meer m, land l WHERE m.l_id = l.l_id ; # Eine mögliche Lösung: WITH europa (l_id,%20l_name%29%20as%20%28%20select%20l.l_id, l.name FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ), europa_paare (l_id1, l_id2) AS ( SELECT l_id1, l_id2 FROM benachbart b WHERE b.l_id1 IN ( SELECT l_id FROM europa )AND b.l_id2 IN ( SELECT l_id FROM europa ) ), land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l1.l_id ´´l1.l_id´´, l1.name ´´l1.name´´, l2.l_id ´´l2.l_id´´, l2.name ´´l2.name´´ FROM land l1, land l2, europa_paare e WHERE l1.l_id = e.l_id1 AND l2.l_id = e.l_id2 AND NOT EXISTS ( SELECT m1.name FROM land_meer m1 WHERE m1.l_id = e.l_id1 EXCEPT ALL SELECT m2.name FROM land_meer m2 WHERE m2.l_id = e.l_id2 ) AND NOT EXISTS ( SELECT m3.name FROM land_meer m3 WHERE m3.l_id = e.l_id2 EXCEPT ALL SELECT m4.name FROM land_meer m4 WHERE m4.l_id = e.l_id1 ) AND EXISTS ( SELECT m5.name FROM land_meer m5 WHERE m5.l_id = e.l_id1 )');alert('2.3.4.2 \nGeben Sie alle Paare von Ländern mit Meeresküste in Europa aus, die an die gleiche Menge von Meeren angrenzen. \nBeispiel: \n[Belgien, Niederlande] \nda M_Belgien = M_Niederlande = {Nordsee} \n[Belgien, Spanien] sollte nicht auftauchen, \nda M_Spanien = {Atlantik, Mittelmeer} \n');"
 onmouseover="show_text_in_form('2.3.4.2 \nGeben Sie alle Paare von Ländern mit Meeresküste in Europa aus, die an die gleiche Menge von Meeren angrenzen. \nBeispiel: \n[Belgien, Niederlande] \nda M_Belgien = M_Niederlande = {Nordsee} \n[Belgien, Spanien] sollte nicht auftauchen, \nda M_Spanien = {Atlantik, Mittelmeer} \n','# Alle Länder-Paare innerhalb Europa: WITH europa (l_id, l_name) AS ( SELECT l.l_id AS ´´l.l_id´´, l.name AS ´´l.name´´ FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ) SELECT l1.name ´´l1.name´´, l2.name ´´l2.name´´ FROM benachbart b, land l1, land l2 WHERE b.l_id1 = l1.l_id AND b.l_id2 = l2.l_id AND b.l_id1 IN (SELECT l_id FROM europa) AND b.l_id2 IN (SELECT l_id FROM europa) # ...57 Paare ; # Zuordnung Land und Meer: WITH land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l.name ´´l.name´´, m.name ´´m.name´´ FROM land_meer m, land l WHERE m.l_id = l.l_id ; # Eine mögliche Lösung: WITH europa (l_id,%20l_name%29%20as%20%28%20select%20l.l_id, l.name FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ), europa_paare (l_id1, l_id2) AS ( SELECT l_id1, l_id2 FROM benachbart b WHERE b.l_id1 IN ( SELECT l_id FROM europa )AND b.l_id2 IN ( SELECT l_id FROM europa ) ), land_meer (l_id,%20name%29%20as%20%28%20select%20l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id =0E3DD6D4, g.name ) SELECT l1.l_id ´´l1.l_id´´, l1.name ´´l1.name´´, l2.l_id ´´l2.l_id´´, l2.name ´´l2.name´´ FROM land l1, land l2, europa_paare e WHERE l1.l_id = e.l_id1 AND l2.l_id = e.l_id2 AND NOT EXISTS ( SELECT m1.name FROM land_meer m1 WHERE m1.l_id = e.l_id1 EXCEPT ALL SELECT m2.name FROM land_meer m2 WHERE m2.l_id = e.l_id2 ) AND NOT EXISTS ( SELECT m3.name FROM land_meer m3 WHERE m3.l_id = e.l_id2 EXCEPT ALL SELECT m4.name FROM land_meer m4 WHERE m4.l_id = e.l_id1 ) AND EXISTS ( SELECT m5.name FROM land_meer m5 WHERE m5.l_id = e.l_id1 )');"
 
 onkeypress="'# Alle Länder-Paare innerhalb Europa: WITH europa (l_id, l_name) AS ( SELECT l.l_id AS ´´l.l_id´´, l.name AS ´´l.name´´ FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ) SELECT l1.name ´´l1.name´´, l2.name ´´l2.name´´ FROM benachbart b, land l1, land l2 WHERE b.l_id1 = l1.l_id AND b.l_id2 = l2.l_id AND b.l_id1 IN (SELECT l_id FROM europa) AND b.l_id2 IN (SELECT l_id FROM europa) # ...57 Paare ; # Zuordnung Land und Meer: WITH land_meer (l_id, name) AS ( SELECT l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id = m.g_id GROUP BY l.l_id, g.name ) SELECT l.name ´´l.name´´, m.name ´´m.name´´ FROM land_meer m, land l WHERE m.l_id = l.l_id ; # Eine mögliche Lösung: WITH europa (l_id, l_name) AS ( SELECT l.l_id, l.name FROM land l, umfasst u, kontinent k WHERE l.l_id = u.l_id AND u.k_id = k.k_id AND k.name = \'Europa\' ), europa_paare (l_id1, l_id2) AS ( SELECT l_id1, l_id2 FROM benachbart b WHERE b.l_id1 IN ( SELECT l_id FROM europa )AND b.l_id2 IN ( SELECT l_id FROM europa ) ), land_meer (l_id, name) AS ( SELECT l.l_id, g.name FROM land l, landesteil lt, geo_gewaesser gg, gewaesser g, meer m WHERE l.l_id = lt.l_id AND lt.lt_id = gg.lt_id AND gg.g_id = g.g_id AND g.g_id = m.g_id GROUP BY l.l_id, g.name ) SELECT l1.l_id ´´l1.l_id´´, l1.name ´´l1.name´´, l2.l_id ´´l2.l_id´´, l2.name ´´l2.name´´ FROM land l1, land l2, europa_paare e WHERE l1.l_id = e.l_id1 AND l2.l_id = e.l_id2 AND NOT EXISTS ( SELECT m1.name FROM land_meer m1 WHERE m1.l_id = e.l_id1 EXCEPT ALL SELECT m2.name FROM land_meer m2 WHERE m2.l_id = e.l_id2 ) AND NOT EXISTS ( SELECT m3.name FROM land_meer m3 WHERE m3.l_id = e.l_id2 EXCEPT ALL SELECT m4.name FROM land_meer m4 WHERE m4.l_id = e.l_id1 ) AND EXISTS ( SELECT m5.name FROM land_meer m5 WHERE m5.l_id = e.l_id1 )'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em><u>2.3.4.3.(a) <b>WITH</b></u> billig von Kapstadt nach New York <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=14.htm"
 onmouseover="show_text_in_form('2.3.4.3.(a) \nFinden Sie die günstigste Flugverbindung von Kapstadt nach New York.','# Theoretisch muss man alle möglichen Verbindungen durchrechnen, das ist bei einem rückgekoppelten Netz nicht möglich -> # Endlosschleife. # Daher wird hier die Zahl der Umstiegen wird auf 5 gesetzt. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Kapstadt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny # , flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id # _and f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'New_York\' AND umstieg < 5 ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 34 ->7 1 ->2 ->3 2 JFK 1673.00');"
 ># T...</a> 
<a href="javascript:show_text_in_form('# Theoretisch muss man alle möglichen Verbindungen durchrechnen, das ist bei einem rückgekoppelten Netz nicht möglich -> # Endlosschleife. # Daher wird hier die Zahl der Umstiegen wird auf 5 gesetzt. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Kapstadt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny # , flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id # _and f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'New_York\' AND umstieg < 5 ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 34 ->7 1 ->2 ->3 2 JFK 1673.00','# Theoretisch muss man alle möglichen Verbindungen durchrechnen, das ist bei einem rückgekoppelten Netz nicht möglich -> # Endlosschleife. # Daher wird hier die Zahl der Umstiegen wird auf 5 gesetzt. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Kapstadt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny # , flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id # _and f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'New_York\' AND umstieg < 5 ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 34 ->7 1 ->2 ->3 2 JFK 1673.00');alert('2.3.4.3.(a) \nFinden Sie die günstigste Flugverbindung von Kapstadt nach New York.');"
 onmouseover="show_text_in_form('2.3.4.3.(a) \nFinden Sie die günstigste Flugverbindung von Kapstadt nach New York.','# Theoretisch muss man alle möglichen Verbindungen durchrechnen, das ist bei einem rückgekoppelten Netz nicht möglich -> # Endlosschleife. # Daher wird hier die Zahl der Umstiegen wird auf 5 gesetzt. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Kapstadt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny # , flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id # _and f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'New_York\' AND umstieg < 5 ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 34 ->7 1 ->2 ->3 2 JFK 1673.00');"
 
 onkeypress="'# Theoretisch muss man alle möglichen Verbindungen durchrechnen, das ist bei einem rückgekoppelten Netz nicht möglich -> # Endlosschleife. # Daher wird hier die Zahl der Umstiegen wird auf 5 gesetzt. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Kapstadt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny # , flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id # _and f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'New_York\' AND umstieg < 5 ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'New_York\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 34 ->7 1 ->2 ->3 2 JFK 1673.00'">Text</a></font><font size="+1"> <b>&#664</b> <em>Aufg.</em><u>2.3.4.3.(b) <b>WITH</b></u> wenig Umstiege von Frankfurt nach Los Angeles <a href="aufgabe4.4.5_v0503082041.php@aufgabennr=15.htm"
 onmouseover="show_text_in_form('2.3.4.3.(b) \nFinden Sie die Verbindung von Frankfurt nach Los Angeles mit den wenigsten \nUmstiegen. Falls mehrere Alternativen bestehen, wählen Sie die günstigste.','# Die Abbruchbedingung aus der Rekursion kann man hier direkt angaben, da hier die Verbindung mit den wenigsten Umstiegen gesucht wird. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Frankfurt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny, flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id AND f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'Los_Angeles\' #AND umstieg < 5 */ ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 7 ->2 2 ->3 ->4 2 LAX 1920.00');"
 ># D...</a> 
<a href="javascript:show_text_in_form('# Die Abbruchbedingung aus der Rekursion kann man hier direkt angaben, da hier die Verbindung mit den wenigsten Umstiegen gesucht wird. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Frankfurt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny, flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id AND f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'Los_Angeles\' #AND umstieg < 5 */ ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 7 ->2 2 ->3 ->4 2 LAX 1920.00','# Die Abbruchbedingung aus der Rekursion kann man hier direkt angaben, da hier die Verbindung mit den wenigsten Umstiegen gesucht wird. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Frankfurt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny, flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id AND f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'Los_Angeles\' #AND umstieg < 5 */ ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 7 ->2 2 ->3 ->4 2 LAX 1920.00');alert('2.3.4.3.(b) \nFinden Sie die Verbindung von Frankfurt nach Los Angeles mit den wenigsten \nUmstiegen. Falls mehrere Alternativen bestehen, wählen Sie die günstigste.');"
 onmouseover="show_text_in_form('2.3.4.3.(b) \nFinden Sie die Verbindung von Frankfurt nach Los Angeles mit den wenigsten \nUmstiegen. Falls mehrere Alternativen bestehen, wählen Sie die günstigste.','# Die Abbruchbedingung aus der Rekursion kann man hier direkt angaben, da hier die Verbindung mit den wenigsten Umstiegen gesucht wird. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Frankfurt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny, flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id AND f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'Los_Angeles\' #AND umstieg < 5 */ ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 7 ->2 2 ->3 ->4 2 LAX 1920.00');"
 
 onkeypress="'# Die Abbruchbedingung aus der Rekursion kann man hier direkt angaben, da hier die Verbindung mit den wenigsten Umstiegen gesucht wird. WITH flug_ny ( flug_id, flug_strecke, fh_strecke, umstieg, abflugfh_id, ankunftfh_id, preis, sum_preis) AS ( ( SELECT f.flug_id, CAST(CAST(f.flug_id AS char(3)) AS varchar(100)), CAST(CAST(f.abflugfh_id AS char(3)) AS varchar(100)) || \'->\' || CAST(CAST(f.ankunftfh_id AS char(3)) AS varchar(100)), 1, f.abflugfh_id, f.ankunftfh_id, f.preis, f.preis FROM flug f, flughafen fh, stadt s WHERE f.abflugfh_id = fh.fh_id AND fh.s_id = s.s_id AND s.name = \'Frankfurt\' ) UNION ALL ( SELECT f1.flug_id, fny.flug_strecke || \'->\' || CAST(CAST(f1.flug_id AS char(3)) AS varchar(100)), fny.fh_strecke || \'->\' || CAST(CAST(f1.ankunftfh_id AS char(3)) AS varchar(100)), fny.umstieg+1, f1.abflugfh_id, f1.ankunftfh_id, f1.preis, f1.preis + fny.sum_preis FROM flug f1, flug_ny fny, flughafen fh1, stadt s1 WHERE f1.abflugfh_id = fny.ankunftfh_id AND f1.ankunftfh_id = fh1.fh_id AND fh1.s_id = s1.s_id AND s1.name = \'Los_Angeles\' #AND umstieg < 5 */ ) ) SELECT flug_strecke, fh_strecke, umstieg, code AS ankunft_fh, sum_preis AS gesamt_preis FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' AND sum_preis = ( SELECT MIN(sum_preis) FROM flug_ny fny2, flughafen fh2, stadt s2 WHERE fny2.ankunftfh_id = fh2.fh_id AND fh2.s_id = s2.s_id AND s2.name = \'Los_Angeles\' ) # FLUG_STRECKE FH_STRECKE UMSTIEG ANKUNFT_FH GESAMT_PREIS # 7 ->2 2 ->3 ->4 2 LAX 1920.00'">Text</a></font><form method="get"><table align="center" border="2" cellpadding="2" cellspacing="0" bordercolor="#ffff00"><tr><td><em>&nbsp;&nbsp;SQL-Befehl fuer DB2</em>&nbsp;&nbsp;&nbsp;&nbsp;<input type="Submit" accesskey="1" value="SQL senden (ALT+1)" onmouseover="load_backup();"  onclick="load_backup();" " >
	<a href="aufgabe4.4.5_v0503082041.php@sql=select%20_2a%20from%20stadt&table_name=stadt.htm">SELECT * FROM stadt</a>
	<br><textarea name="sql" cols="100" rows="3"  onclick="load_backup();" "  onmouseover="load_backup();"  onchange="set_backup();"  onfocus="this.select();" "  accesskey="2">SELECT S.stadt AS "S.stadt", S.land AS "S.land" 
FROM STADT AS S
                                                                             ; # focus hier ALT+2
# Die Standard SELECTS * oben, erhällt man auch über
# ALT+(Erster Buchstabe der Tabelle.)+ENTER 
# odbc_num_rows: Syntax-Fehler ,  odbc_num_fields: Syntax-Fehler</textarea></td></tr></table>odbc_exec misslungen! (<font size=-3></font>)<table border="1" cellspacing="0" cellpadding="0" width="100%"><tr><td valign="top" bgcolor="#FFFFFF" nowrap><font color="Black"><font size="-1"><br><font size="-2"><a href="" target="o"></a></font></font></td></tr><tr><td bgcolor="#FFCC99" width="100%"><font color="Black">SELECT S.stadt AS "S.stadt", S.land AS "S.land" <br>
FROM STADT AS S<br>
[IBM][CLI Driver][DB2/NT] SQL0206N&nbsp; "S.STADT" ist in dem verwendeten Kontext ungültig.&nbsp; SQLSTATE=42703<br>
</font></td></tr></table><form name="f1111000845"><input type="Button" style="font-size: 9px; color: black; border: 0px White; background: White;" name="f1111000845" value="Jump"></form><script language="JavaScript">
         document.forms["f1111000845"].elements["f1111000845"].focus();
         </script><table border="5" cellspacing="0" cellpadding="0" width="100%"><tr><td valign="top" bgcolor="#FFFFFF" nowrap><font color="Black"><font size="-1">&nbsp;&nbsp;<b>Anzahl</b> der <u>veränderten</u> bzw. <u>eingefügten</u> / <u>gelöschten</u> Tupel:&nbsp;<br><font size="-2"><a href="" target="o"></a></font></font></td><td bgcolor="#ffffff" width="100%"><font color="Black">&nbsp;&nbsp;<b>Syntax-Fehler</b>&nbsp;&nbsp;(<font size=-2>odbc_num_rows(  )=<b>Syntax-Fehler</b> odbc_num_fields(  )=<b>Syntax-Fehler</b></font>)</font></td></tr></table></table></form><br></body></html>